{"ast":null,"code":"import { e as error, G as GameMethod, a as GetAPIs, T as TurnOrder, b as supportDeprecatedMoveLimit, S as Stage, c as SetActivePlayers, i as info, F as FnWrap, I as InitTurnOrderState, U as UpdateTurnOrderState, d as UpdateActivePlayersOnceEmpty, g as gameEvent, P as PATCH, f as PLUGIN, h as ProcessAction, R as REDO, j as UNDO, k as SYNC, l as UPDATE, m as RESET, M as MAKE_MOVE, E as Enhance, n as INVALID_MOVE, N as NoClient, o as GAME_EVENT, p as STRIP_TRANSIENTS, q as FlushAndValidate, r as stripTransients } from './turn-order-8cc4909b.js';\nimport { applyPatch } from 'rfc6902';\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n/**\r\n * Flow\r\n *\r\n * Creates a reducer that updates ctx (analogous to how moves update G).\r\n */\nfunction Flow(_ref) {\n  let {\n    moves,\n    phases,\n    endIf,\n    onEnd,\n    turn,\n    events,\n    plugins\n  } = _ref;\n  // Attach defaults.\n  if (moves === undefined) {\n    moves = {};\n  }\n  if (events === undefined) {\n    events = {};\n  }\n  if (plugins === undefined) {\n    plugins = [];\n  }\n  if (phases === undefined) {\n    phases = {};\n  }\n  if (!endIf) endIf = () => undefined;\n  if (!onEnd) onEnd = _ref2 => {\n    let {\n      G\n    } = _ref2;\n    return G;\n  };\n  if (!turn) turn = {};\n  const phaseMap = {\n    ...phases\n  };\n  if ('' in phaseMap) {\n    error('cannot specify phase with empty name');\n  }\n  phaseMap[''] = {};\n  const moveMap = {};\n  const moveNames = new Set();\n  let startingPhase = null;\n  Object.keys(moves).forEach(name => moveNames.add(name));\n  const HookWrapper = (hook, hookType) => {\n    const withPlugins = FnWrap(hook, hookType, plugins);\n    return state => {\n      const pluginAPIs = GetAPIs(state);\n      return withPlugins({\n        ...pluginAPIs,\n        G: state.G,\n        ctx: state.ctx,\n        playerID: state.playerID\n      });\n    };\n  };\n  const TriggerWrapper = trigger => {\n    return state => {\n      const pluginAPIs = GetAPIs(state);\n      return trigger({\n        ...pluginAPIs,\n        G: state.G,\n        ctx: state.ctx\n      });\n    };\n  };\n  const wrapped = {\n    onEnd: HookWrapper(onEnd, GameMethod.GAME_ON_END),\n    endIf: TriggerWrapper(endIf)\n  };\n  for (const phase in phaseMap) {\n    const phaseConfig = phaseMap[phase];\n    if (phaseConfig.start === true) {\n      startingPhase = phase;\n    }\n    if (phaseConfig.moves !== undefined) {\n      for (const move of Object.keys(phaseConfig.moves)) {\n        moveMap[phase + '.' + move] = phaseConfig.moves[move];\n        moveNames.add(move);\n      }\n    }\n    if (phaseConfig.endIf === undefined) {\n      phaseConfig.endIf = () => undefined;\n    }\n    if (phaseConfig.onBegin === undefined) {\n      phaseConfig.onBegin = _ref3 => {\n        let {\n          G\n        } = _ref3;\n        return G;\n      };\n    }\n    if (phaseConfig.onEnd === undefined) {\n      phaseConfig.onEnd = _ref4 => {\n        let {\n          G\n        } = _ref4;\n        return G;\n      };\n    }\n    if (phaseConfig.turn === undefined) {\n      phaseConfig.turn = turn;\n    }\n    if (phaseConfig.turn.order === undefined) {\n      phaseConfig.turn.order = TurnOrder.DEFAULT;\n    }\n    if (phaseConfig.turn.onBegin === undefined) {\n      phaseConfig.turn.onBegin = _ref5 => {\n        let {\n          G\n        } = _ref5;\n        return G;\n      };\n    }\n    if (phaseConfig.turn.onEnd === undefined) {\n      phaseConfig.turn.onEnd = _ref6 => {\n        let {\n          G\n        } = _ref6;\n        return G;\n      };\n    }\n    if (phaseConfig.turn.endIf === undefined) {\n      phaseConfig.turn.endIf = () => false;\n    }\n    if (phaseConfig.turn.onMove === undefined) {\n      phaseConfig.turn.onMove = _ref7 => {\n        let {\n          G\n        } = _ref7;\n        return G;\n      };\n    }\n    if (phaseConfig.turn.stages === undefined) {\n      phaseConfig.turn.stages = {};\n    }\n    // turns previously treated moveLimit as both minMoves and maxMoves, this behaviour is kept intentionally\n    supportDeprecatedMoveLimit(phaseConfig.turn, true);\n    for (const stage in phaseConfig.turn.stages) {\n      const stageConfig = phaseConfig.turn.stages[stage];\n      const moves = stageConfig.moves || {};\n      for (const move of Object.keys(moves)) {\n        const key = phase + '.' + stage + '.' + move;\n        moveMap[key] = moves[move];\n        moveNames.add(move);\n      }\n    }\n    phaseConfig.wrapped = {\n      onBegin: HookWrapper(phaseConfig.onBegin, GameMethod.PHASE_ON_BEGIN),\n      onEnd: HookWrapper(phaseConfig.onEnd, GameMethod.PHASE_ON_END),\n      endIf: TriggerWrapper(phaseConfig.endIf)\n    };\n    phaseConfig.turn.wrapped = {\n      onMove: HookWrapper(phaseConfig.turn.onMove, GameMethod.TURN_ON_MOVE),\n      onBegin: HookWrapper(phaseConfig.turn.onBegin, GameMethod.TURN_ON_BEGIN),\n      onEnd: HookWrapper(phaseConfig.turn.onEnd, GameMethod.TURN_ON_END),\n      endIf: TriggerWrapper(phaseConfig.turn.endIf)\n    };\n    if (typeof phaseConfig.next !== 'function') {\n      const {\n        next\n      } = phaseConfig;\n      phaseConfig.next = () => next || null;\n    }\n    phaseConfig.wrapped.next = TriggerWrapper(phaseConfig.next);\n  }\n  function GetPhase(ctx) {\n    return ctx.phase ? phaseMap[ctx.phase] : phaseMap[''];\n  }\n  function OnMove(state) {\n    return state;\n  }\n  function Process(state, events) {\n    const phasesEnded = new Set();\n    const turnsEnded = new Set();\n    for (let i = 0; i < events.length; i++) {\n      const {\n        fn,\n        arg,\n        ...rest\n      } = events[i];\n      // Detect a loop of EndPhase calls.\n      // This could potentially even be an infinite loop\n      // if the endIf condition of each phase blindly\n      // returns true. The moment we detect a single\n      // loop, we just bail out of all phases.\n      if (fn === EndPhase) {\n        turnsEnded.clear();\n        const phase = state.ctx.phase;\n        if (phasesEnded.has(phase)) {\n          const ctx = {\n            ...state.ctx,\n            phase: null\n          };\n          return {\n            ...state,\n            ctx\n          };\n        }\n        phasesEnded.add(phase);\n      }\n      // Process event.\n      const next = [];\n      state = fn(state, {\n        ...rest,\n        arg,\n        next\n      });\n      if (fn === EndGame) {\n        break;\n      }\n      // Check if we should end the game.\n      const shouldEndGame = ShouldEndGame(state);\n      if (shouldEndGame) {\n        events.push({\n          fn: EndGame,\n          arg: shouldEndGame,\n          turn: state.ctx.turn,\n          phase: state.ctx.phase,\n          automatic: true\n        });\n        continue;\n      }\n      // Check if we should end the phase.\n      const shouldEndPhase = ShouldEndPhase(state);\n      if (shouldEndPhase) {\n        events.push({\n          fn: EndPhase,\n          arg: shouldEndPhase,\n          turn: state.ctx.turn,\n          phase: state.ctx.phase,\n          automatic: true\n        });\n        continue;\n      }\n      // Check if we should end the turn.\n      if ([OnMove, UpdateStage, UpdateActivePlayers].includes(fn)) {\n        const shouldEndTurn = ShouldEndTurn(state);\n        if (shouldEndTurn) {\n          events.push({\n            fn: EndTurn,\n            arg: shouldEndTurn,\n            turn: state.ctx.turn,\n            phase: state.ctx.phase,\n            automatic: true\n          });\n          continue;\n        }\n      }\n      events.push(...next);\n    }\n    return state;\n  }\n  ///////////\n  // Start //\n  ///////////\n  function StartGame(state, _ref8) {\n    let {\n      next\n    } = _ref8;\n    next.push({\n      fn: StartPhase\n    });\n    return state;\n  }\n  function StartPhase(state, _ref9) {\n    let {\n      next\n    } = _ref9;\n    let {\n      G,\n      ctx\n    } = state;\n    const phaseConfig = GetPhase(ctx);\n    // Run any phase setup code provided by the user.\n    G = phaseConfig.wrapped.onBegin(state);\n    next.push({\n      fn: StartTurn\n    });\n    return {\n      ...state,\n      G,\n      ctx\n    };\n  }\n  function StartTurn(state, _ref10) {\n    let {\n      currentPlayer\n    } = _ref10;\n    let {\n      ctx\n    } = state;\n    const phaseConfig = GetPhase(ctx);\n    // Initialize the turn order state.\n    if (currentPlayer) {\n      ctx = {\n        ...ctx,\n        currentPlayer\n      };\n      if (phaseConfig.turn.activePlayers) {\n        ctx = SetActivePlayers(ctx, phaseConfig.turn.activePlayers);\n      }\n    } else {\n      // This is only called at the beginning of the phase\n      // when there is no currentPlayer yet.\n      ctx = InitTurnOrderState(state, phaseConfig.turn);\n    }\n    const turn = ctx.turn + 1;\n    ctx = {\n      ...ctx,\n      turn,\n      numMoves: 0,\n      _prevActivePlayers: []\n    };\n    const G = phaseConfig.turn.wrapped.onBegin({\n      ...state,\n      ctx\n    });\n    return {\n      ...state,\n      G,\n      ctx,\n      _undo: [],\n      _redo: []\n    };\n  }\n  ////////////\n  // Update //\n  ////////////\n  function UpdatePhase(state, _ref11) {\n    let {\n      arg,\n      next,\n      phase\n    } = _ref11;\n    const phaseConfig = GetPhase({\n      phase\n    });\n    let {\n      ctx\n    } = state;\n    if (arg && arg.next) {\n      if (arg.next in phaseMap) {\n        ctx = {\n          ...ctx,\n          phase: arg.next\n        };\n      } else {\n        error('invalid phase: ' + arg.next);\n        return state;\n      }\n    } else {\n      ctx = {\n        ...ctx,\n        phase: phaseConfig.wrapped.next(state) || null\n      };\n    }\n    state = {\n      ...state,\n      ctx\n    };\n    // Start the new phase.\n    next.push({\n      fn: StartPhase\n    });\n    return state;\n  }\n  function UpdateTurn(state, _ref12) {\n    let {\n      arg,\n      currentPlayer,\n      next\n    } = _ref12;\n    let {\n      G,\n      ctx\n    } = state;\n    const phaseConfig = GetPhase(ctx);\n    // Update turn order state.\n    const {\n      endPhase,\n      ctx: newCtx\n    } = UpdateTurnOrderState(state, currentPlayer, phaseConfig.turn, arg);\n    ctx = newCtx;\n    state = {\n      ...state,\n      G,\n      ctx\n    };\n    if (endPhase) {\n      next.push({\n        fn: EndPhase,\n        turn: ctx.turn,\n        phase: ctx.phase\n      });\n    } else {\n      next.push({\n        fn: StartTurn,\n        currentPlayer: ctx.currentPlayer\n      });\n    }\n    return state;\n  }\n  function UpdateStage(state, _ref13) {\n    let {\n      arg,\n      playerID\n    } = _ref13;\n    if (typeof arg === 'string' || arg === Stage.NULL) {\n      arg = {\n        stage: arg\n      };\n    }\n    if (typeof arg !== 'object') return state;\n    // `arg` should be of type `StageArg`, loose typing as `any` here for historic reasons\n    // stages previously did not enforce minMoves, this behaviour is kept intentionally\n    supportDeprecatedMoveLimit(arg);\n    let {\n      ctx\n    } = state;\n    let {\n      activePlayers,\n      _activePlayersMinMoves,\n      _activePlayersMaxMoves,\n      _activePlayersNumMoves\n    } = ctx;\n    // Checking if stage is valid, even Stage.NULL\n    if (arg.stage !== undefined) {\n      if (activePlayers === null) {\n        activePlayers = {};\n      }\n      activePlayers[playerID] = arg.stage;\n      _activePlayersNumMoves[playerID] = 0;\n      if (arg.minMoves) {\n        if (_activePlayersMinMoves === null) {\n          _activePlayersMinMoves = {};\n        }\n        _activePlayersMinMoves[playerID] = arg.minMoves;\n      }\n      if (arg.maxMoves) {\n        if (_activePlayersMaxMoves === null) {\n          _activePlayersMaxMoves = {};\n        }\n        _activePlayersMaxMoves[playerID] = arg.maxMoves;\n      }\n    }\n    ctx = {\n      ...ctx,\n      activePlayers,\n      _activePlayersMinMoves,\n      _activePlayersMaxMoves,\n      _activePlayersNumMoves\n    };\n    return {\n      ...state,\n      ctx\n    };\n  }\n  function UpdateActivePlayers(state, _ref14) {\n    let {\n      arg\n    } = _ref14;\n    return {\n      ...state,\n      ctx: SetActivePlayers(state.ctx, arg)\n    };\n  }\n  ///////////////\n  // ShouldEnd //\n  ///////////////\n  function ShouldEndGame(state) {\n    return wrapped.endIf(state);\n  }\n  function ShouldEndPhase(state) {\n    const phaseConfig = GetPhase(state.ctx);\n    return phaseConfig.wrapped.endIf(state);\n  }\n  function ShouldEndTurn(state) {\n    const phaseConfig = GetPhase(state.ctx);\n    // End the turn if the required number of moves has been made.\n    const currentPlayerMoves = state.ctx.numMoves || 0;\n    if (phaseConfig.turn.maxMoves && currentPlayerMoves >= phaseConfig.turn.maxMoves) {\n      return true;\n    }\n    return phaseConfig.turn.wrapped.endIf(state);\n  }\n  /////////\n  // End //\n  /////////\n  function EndGame(state, _ref15) {\n    let {\n      arg,\n      phase\n    } = _ref15;\n    state = EndPhase(state, {\n      phase\n    });\n    if (arg === undefined) {\n      arg = true;\n    }\n    state = {\n      ...state,\n      ctx: {\n        ...state.ctx,\n        gameover: arg\n      }\n    };\n    // Run game end hook.\n    const G = wrapped.onEnd(state);\n    return {\n      ...state,\n      G\n    };\n  }\n  function EndPhase(state, _ref16) {\n    let {\n      arg,\n      next,\n      turn: initialTurn,\n      automatic\n    } = _ref16;\n    // End the turn first.\n    state = EndTurn(state, {\n      turn: initialTurn,\n      force: true,\n      automatic: true\n    });\n    const {\n      phase,\n      turn\n    } = state.ctx;\n    if (next) {\n      next.push({\n        fn: UpdatePhase,\n        arg,\n        phase\n      });\n    }\n    // If we aren't in a phase, there is nothing else to do.\n    if (phase === null) {\n      return state;\n    }\n    // Run any cleanup code for the phase that is about to end.\n    const phaseConfig = GetPhase(state.ctx);\n    const G = phaseConfig.wrapped.onEnd(state);\n    // Reset the phase.\n    const ctx = {\n      ...state.ctx,\n      phase: null\n    };\n    // Add log entry.\n    const action = gameEvent('endPhase', arg);\n    const {\n      _stateID\n    } = state;\n    const logEntry = {\n      action,\n      _stateID,\n      turn,\n      phase\n    };\n    if (automatic) logEntry.automatic = true;\n    const deltalog = [...(state.deltalog || []), logEntry];\n    return {\n      ...state,\n      G,\n      ctx,\n      deltalog\n    };\n  }\n  function EndTurn(state, _ref17) {\n    let {\n      arg,\n      next,\n      turn: initialTurn,\n      force,\n      automatic,\n      playerID\n    } = _ref17;\n    // This is not the turn that EndTurn was originally\n    // called for. The turn was probably ended some other way.\n    if (initialTurn !== state.ctx.turn) {\n      return state;\n    }\n    const {\n      currentPlayer,\n      numMoves,\n      phase,\n      turn\n    } = state.ctx;\n    const phaseConfig = GetPhase(state.ctx);\n    // Prevent ending the turn if minMoves haven't been reached.\n    const currentPlayerMoves = numMoves || 0;\n    if (!force && phaseConfig.turn.minMoves && currentPlayerMoves < phaseConfig.turn.minMoves) {\n      info(`cannot end turn before making ${phaseConfig.turn.minMoves} moves`);\n      return state;\n    }\n    // Run turn-end triggers.\n    const G = phaseConfig.turn.wrapped.onEnd(state);\n    if (next) {\n      next.push({\n        fn: UpdateTurn,\n        arg,\n        currentPlayer\n      });\n    }\n    // Reset activePlayers.\n    let ctx = {\n      ...state.ctx,\n      activePlayers: null\n    };\n    // Remove player from playerOrder\n    if (arg && arg.remove) {\n      playerID = playerID || currentPlayer;\n      const playOrder = ctx.playOrder.filter(i => i != playerID);\n      const playOrderPos = ctx.playOrderPos > playOrder.length - 1 ? 0 : ctx.playOrderPos;\n      ctx = {\n        ...ctx,\n        playOrder,\n        playOrderPos\n      };\n      if (playOrder.length === 0) {\n        next.push({\n          fn: EndPhase,\n          turn,\n          phase\n        });\n        return state;\n      }\n    }\n    // Create log entry.\n    const action = gameEvent('endTurn', arg);\n    const {\n      _stateID\n    } = state;\n    const logEntry = {\n      action,\n      _stateID,\n      turn,\n      phase\n    };\n    if (automatic) logEntry.automatic = true;\n    const deltalog = [...(state.deltalog || []), logEntry];\n    return {\n      ...state,\n      G,\n      ctx,\n      deltalog,\n      _undo: [],\n      _redo: []\n    };\n  }\n  function EndStage(state, _ref18) {\n    let {\n      arg,\n      next,\n      automatic,\n      playerID\n    } = _ref18;\n    playerID = playerID || state.ctx.currentPlayer;\n    let {\n      ctx,\n      _stateID\n    } = state;\n    let {\n      activePlayers,\n      _activePlayersNumMoves,\n      _activePlayersMinMoves,\n      _activePlayersMaxMoves,\n      phase,\n      turn\n    } = ctx;\n    const playerInStage = activePlayers !== null && playerID in activePlayers;\n    const phaseConfig = GetPhase(ctx);\n    if (!arg && playerInStage) {\n      const stage = phaseConfig.turn.stages[activePlayers[playerID]];\n      if (stage && stage.next) {\n        arg = stage.next;\n      }\n    }\n    // Checking if arg is a valid stage, even Stage.NULL\n    if (next) {\n      next.push({\n        fn: UpdateStage,\n        arg,\n        playerID\n      });\n    }\n    // If player isn’t in a stage, there is nothing else to do.\n    if (!playerInStage) return state;\n    // Prevent ending the stage if minMoves haven't been reached.\n    const currentPlayerMoves = _activePlayersNumMoves[playerID] || 0;\n    if (_activePlayersMinMoves && _activePlayersMinMoves[playerID] && currentPlayerMoves < _activePlayersMinMoves[playerID]) {\n      info(`cannot end stage before making ${_activePlayersMinMoves[playerID]} moves`);\n      return state;\n    }\n    // Remove player from activePlayers.\n    activePlayers = {\n      ...activePlayers\n    };\n    delete activePlayers[playerID];\n    if (_activePlayersMinMoves) {\n      // Remove player from _activePlayersMinMoves.\n      _activePlayersMinMoves = {\n        ..._activePlayersMinMoves\n      };\n      delete _activePlayersMinMoves[playerID];\n    }\n    if (_activePlayersMaxMoves) {\n      // Remove player from _activePlayersMaxMoves.\n      _activePlayersMaxMoves = {\n        ..._activePlayersMaxMoves\n      };\n      delete _activePlayersMaxMoves[playerID];\n    }\n    ctx = UpdateActivePlayersOnceEmpty({\n      ...ctx,\n      activePlayers,\n      _activePlayersMinMoves,\n      _activePlayersMaxMoves\n    });\n    // Create log entry.\n    const action = gameEvent('endStage', arg);\n    const logEntry = {\n      action,\n      _stateID,\n      turn,\n      phase\n    };\n    if (automatic) logEntry.automatic = true;\n    const deltalog = [...(state.deltalog || []), logEntry];\n    return {\n      ...state,\n      ctx,\n      deltalog\n    };\n  }\n  /**\r\n   * Retrieves the relevant move that can be played by playerID.\r\n   *\r\n   * If ctx.activePlayers is set (i.e. one or more players are in some stage),\r\n   * then it attempts to find the move inside the stages config for\r\n   * that turn. If the stage for a player is '', then the player is\r\n   * allowed to make a move (as determined by the phase config), but\r\n   * isn't restricted to a particular set as defined in the stage config.\r\n   *\r\n   * If not, it then looks for the move inside the phase.\r\n   *\r\n   * If it doesn't find the move there, it looks at the global move definition.\r\n   *\r\n   * @param {object} ctx\r\n   * @param {string} name\r\n   * @param {string} playerID\r\n   */\n  function GetMove(ctx, name, playerID) {\n    const phaseConfig = GetPhase(ctx);\n    const stages = phaseConfig.turn.stages;\n    const {\n      activePlayers\n    } = ctx;\n    if (activePlayers && activePlayers[playerID] !== undefined && activePlayers[playerID] !== Stage.NULL && stages[activePlayers[playerID]] !== undefined && stages[activePlayers[playerID]].moves !== undefined) {\n      // Check if moves are defined for the player's stage.\n      const stage = stages[activePlayers[playerID]];\n      const moves = stage.moves;\n      if (name in moves) {\n        return moves[name];\n      }\n    } else if (phaseConfig.moves) {\n      // Check if moves are defined for the current phase.\n      if (name in phaseConfig.moves) {\n        return phaseConfig.moves[name];\n      }\n    } else if (name in moves) {\n      // Check for the move globally.\n      return moves[name];\n    }\n    return null;\n  }\n  function ProcessMove(state, action) {\n    const {\n      playerID,\n      type\n    } = action;\n    const {\n      currentPlayer,\n      activePlayers,\n      _activePlayersMaxMoves\n    } = state.ctx;\n    const move = GetMove(state.ctx, type, playerID);\n    const shouldCount = !move || typeof move === 'function' || move.noLimit !== true;\n    let {\n      numMoves,\n      _activePlayersNumMoves\n    } = state.ctx;\n    if (shouldCount) {\n      if (playerID === currentPlayer) numMoves++;\n      if (activePlayers) _activePlayersNumMoves[playerID]++;\n    }\n    state = {\n      ...state,\n      ctx: {\n        ...state.ctx,\n        numMoves,\n        _activePlayersNumMoves\n      }\n    };\n    if (_activePlayersMaxMoves && _activePlayersNumMoves[playerID] >= _activePlayersMaxMoves[playerID]) {\n      state = EndStage(state, {\n        playerID,\n        automatic: true\n      });\n    }\n    const phaseConfig = GetPhase(state.ctx);\n    const G = phaseConfig.turn.wrapped.onMove({\n      ...state,\n      playerID\n    });\n    state = {\n      ...state,\n      G\n    };\n    const events = [{\n      fn: OnMove\n    }];\n    return Process(state, events);\n  }\n  function SetStageEvent(state, playerID, arg) {\n    return Process(state, [{\n      fn: EndStage,\n      arg,\n      playerID\n    }]);\n  }\n  function EndStageEvent(state, playerID) {\n    return Process(state, [{\n      fn: EndStage,\n      playerID\n    }]);\n  }\n  function SetActivePlayersEvent(state, _playerID, arg) {\n    return Process(state, [{\n      fn: UpdateActivePlayers,\n      arg\n    }]);\n  }\n  function SetPhaseEvent(state, _playerID, newPhase) {\n    return Process(state, [{\n      fn: EndPhase,\n      phase: state.ctx.phase,\n      turn: state.ctx.turn,\n      arg: {\n        next: newPhase\n      }\n    }]);\n  }\n  function EndPhaseEvent(state) {\n    return Process(state, [{\n      fn: EndPhase,\n      phase: state.ctx.phase,\n      turn: state.ctx.turn\n    }]);\n  }\n  function EndTurnEvent(state, _playerID, arg) {\n    return Process(state, [{\n      fn: EndTurn,\n      turn: state.ctx.turn,\n      phase: state.ctx.phase,\n      arg\n    }]);\n  }\n  function PassEvent(state, _playerID, arg) {\n    return Process(state, [{\n      fn: EndTurn,\n      turn: state.ctx.turn,\n      phase: state.ctx.phase,\n      force: true,\n      arg\n    }]);\n  }\n  function EndGameEvent(state, _playerID, arg) {\n    return Process(state, [{\n      fn: EndGame,\n      turn: state.ctx.turn,\n      phase: state.ctx.phase,\n      arg\n    }]);\n  }\n  const eventHandlers = {\n    endStage: EndStageEvent,\n    setStage: SetStageEvent,\n    endTurn: EndTurnEvent,\n    pass: PassEvent,\n    endPhase: EndPhaseEvent,\n    setPhase: SetPhaseEvent,\n    endGame: EndGameEvent,\n    setActivePlayers: SetActivePlayersEvent\n  };\n  const enabledEventNames = [];\n  if (events.endTurn !== false) {\n    enabledEventNames.push('endTurn');\n  }\n  if (events.pass !== false) {\n    enabledEventNames.push('pass');\n  }\n  if (events.endPhase !== false) {\n    enabledEventNames.push('endPhase');\n  }\n  if (events.setPhase !== false) {\n    enabledEventNames.push('setPhase');\n  }\n  if (events.endGame !== false) {\n    enabledEventNames.push('endGame');\n  }\n  if (events.setActivePlayers !== false) {\n    enabledEventNames.push('setActivePlayers');\n  }\n  if (events.endStage !== false) {\n    enabledEventNames.push('endStage');\n  }\n  if (events.setStage !== false) {\n    enabledEventNames.push('setStage');\n  }\n  function ProcessEvent(state, action) {\n    const {\n      type,\n      playerID,\n      args\n    } = action.payload;\n    if (typeof eventHandlers[type] !== 'function') return state;\n    return eventHandlers[type](state, playerID, ...(Array.isArray(args) ? args : [args]));\n  }\n  function IsPlayerActive(_G, ctx, playerID) {\n    if (ctx.activePlayers) {\n      return playerID in ctx.activePlayers;\n    }\n    return ctx.currentPlayer === playerID;\n  }\n  return {\n    ctx: numPlayers => ({\n      numPlayers,\n      turn: 0,\n      currentPlayer: '0',\n      playOrder: [...Array.from({\n        length: numPlayers\n      })].map((_, i) => i + ''),\n      playOrderPos: 0,\n      phase: startingPhase,\n      activePlayers: null\n    }),\n    init: state => {\n      return Process(state, [{\n        fn: StartGame\n      }]);\n    },\n    isPlayerActive: IsPlayerActive,\n    eventHandlers,\n    eventNames: Object.keys(eventHandlers),\n    enabledEventNames,\n    moveMap,\n    moveNames: [...moveNames.values()],\n    processMove: ProcessMove,\n    processEvent: ProcessEvent,\n    getMove: GetMove\n  };\n}\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\nfunction IsProcessed(game) {\n  return game.processMove !== undefined;\n}\n/**\r\n * Helper to generate the game move reducer. The returned\r\n * reducer has the following signature:\r\n *\r\n * (G, action, ctx) => {}\r\n *\r\n * You can roll your own if you like, or use any Redux\r\n * addon to generate such a reducer.\r\n *\r\n * The convention used in this framework is to\r\n * have action.type contain the name of the move, and\r\n * action.args contain any additional arguments as an\r\n * Array.\r\n */\nfunction ProcessGameConfig(game) {\n  // The Game() function has already been called on this\n  // config object, so just pass it through.\n  if (IsProcessed(game)) {\n    return game;\n  }\n  if (game.name === undefined) game.name = 'default';\n  if (game.deltaState === undefined) game.deltaState = false;\n  if (game.disableUndo === undefined) game.disableUndo = false;\n  if (game.setup === undefined) game.setup = () => ({});\n  if (game.moves === undefined) game.moves = {};\n  if (game.playerView === undefined) game.playerView = _ref19 => {\n    let {\n      G\n    } = _ref19;\n    return G;\n  };\n  if (game.plugins === undefined) game.plugins = [];\n  game.plugins.forEach(plugin => {\n    if (plugin.name === undefined) {\n      throw new Error('Plugin missing name attribute');\n    }\n    if (plugin.name.includes(' ')) {\n      throw new Error(plugin.name + ': Plugin name must not include spaces');\n    }\n  });\n  if (game.name.includes(' ')) {\n    throw new Error(game.name + ': Game name must not include spaces');\n  }\n  const flow = Flow(game);\n  return {\n    ...game,\n    flow,\n    moveNames: flow.moveNames,\n    pluginNames: game.plugins.map(p => p.name),\n    processMove: (state, action) => {\n      let moveFn = flow.getMove(state.ctx, action.type, action.playerID);\n      if (IsLongFormMove(moveFn)) {\n        moveFn = moveFn.move;\n      }\n      if (moveFn instanceof Function) {\n        const fn = FnWrap(moveFn, GameMethod.MOVE, game.plugins);\n        let args = [];\n        if (action.args !== undefined) {\n          args = Array.isArray(action.args) ? action.args : [action.args];\n        }\n        const context = {\n          ...GetAPIs(state),\n          G: state.G,\n          ctx: state.ctx,\n          playerID: action.playerID\n        };\n        return fn(context, ...args);\n      }\n      error(`invalid move object: ${action.type}`);\n      return state.G;\n    }\n  };\n}\nfunction IsLongFormMove(move) {\n  return move instanceof Object && move.move !== undefined;\n}\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\nvar UpdateErrorType;\n(function (UpdateErrorType) {\n  // The action’s credentials were missing or invalid\n  UpdateErrorType[\"UnauthorizedAction\"] = \"update/unauthorized_action\";\n  // The action’s matchID was not found\n  UpdateErrorType[\"MatchNotFound\"] = \"update/match_not_found\";\n  // Could not apply Patch operation (rfc6902).\n  UpdateErrorType[\"PatchFailed\"] = \"update/patch_failed\";\n})(UpdateErrorType || (UpdateErrorType = {}));\nvar ActionErrorType;\n(function (ActionErrorType) {\n  // The action contained a stale state ID\n  ActionErrorType[\"StaleStateId\"] = \"action/stale_state_id\";\n  // The requested move is unknown or not currently available\n  ActionErrorType[\"UnavailableMove\"] = \"action/unavailable_move\";\n  // The move declared it was invalid (INVALID_MOVE constant)\n  ActionErrorType[\"InvalidMove\"] = \"action/invalid_move\";\n  // The player making the action is not currently active\n  ActionErrorType[\"InactivePlayer\"] = \"action/inactive_player\";\n  // The game has finished\n  ActionErrorType[\"GameOver\"] = \"action/gameover\";\n  // The requested action is disabled (e.g. undo/redo, events)\n  ActionErrorType[\"ActionDisabled\"] = \"action/action_disabled\";\n  // The requested action is not currently possible\n  ActionErrorType[\"ActionInvalid\"] = \"action/action_invalid\";\n  // The requested action was declared invalid by a plugin\n  ActionErrorType[\"PluginActionInvalid\"] = \"action/plugin_invalid\";\n})(ActionErrorType || (ActionErrorType = {}));\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n/**\r\n * Check if the payload for the passed action contains a playerID.\r\n */\nconst actionHasPlayerID = action => action.payload.playerID !== null && action.payload.playerID !== undefined;\n/**\r\n * Returns true if a move can be undone.\r\n */\nconst CanUndoMove = (G, ctx, move) => {\n  function HasUndoable(move) {\n    return move.undoable !== undefined;\n  }\n  function IsFunction(undoable) {\n    return undoable instanceof Function;\n  }\n  if (!HasUndoable(move)) {\n    return true;\n  }\n  if (IsFunction(move.undoable)) {\n    return move.undoable({\n      G,\n      ctx\n    });\n  }\n  return move.undoable;\n};\n/**\r\n * Update the undo and redo stacks for a move or event.\r\n */\nfunction updateUndoRedoState(state, opts) {\n  if (opts.game.disableUndo) return state;\n  const undoEntry = {\n    G: state.G,\n    ctx: state.ctx,\n    plugins: state.plugins,\n    playerID: opts.action.payload.playerID || state.ctx.currentPlayer\n  };\n  if (opts.action.type === 'MAKE_MOVE') {\n    undoEntry.moveType = opts.action.payload.type;\n  }\n  return {\n    ...state,\n    _undo: [...state._undo, undoEntry],\n    // Always reset redo stack when making a move or event\n    _redo: []\n  };\n}\n/**\r\n * Process state, adding the initial deltalog for this action.\r\n */\nfunction initializeDeltalog(state, action, move) {\n  // Create a log entry for this action.\n  const logEntry = {\n    action,\n    _stateID: state._stateID,\n    turn: state.ctx.turn,\n    phase: state.ctx.phase\n  };\n  const pluginLogMetadata = state.plugins.log.data.metadata;\n  if (pluginLogMetadata !== undefined) {\n    logEntry.metadata = pluginLogMetadata;\n  }\n  if (typeof move === 'object' && move.redact === true) {\n    logEntry.redact = true;\n  } else if (typeof move === 'object' && move.redact instanceof Function) {\n    logEntry.redact = move.redact({\n      G: state.G,\n      ctx: state.ctx\n    });\n  }\n  return {\n    ...state,\n    deltalog: [logEntry]\n  };\n}\n/**\r\n * Update plugin state after move/event & check if plugins consider the action to be valid.\r\n * @param state Current version of state in the reducer.\r\n * @param oldState State to revert to in case of error.\r\n * @param pluginOpts Plugin configuration options.\r\n * @returns Tuple of the new state updated after flushing plugins and the old\r\n * state augmented with an error if a plugin declared the action invalid.\r\n */\nfunction flushAndValidatePlugins(state, oldState, pluginOpts) {\n  const [newState, isInvalid] = FlushAndValidate(state, pluginOpts);\n  if (!isInvalid) return [newState];\n  return [newState, WithError(oldState, ActionErrorType.PluginActionInvalid, isInvalid)];\n}\n/**\r\n * ExtractTransientsFromState\r\n *\r\n * Split out transients from the a TransientState\r\n */\nfunction ExtractTransients(transientState) {\n  if (!transientState) {\n    // We preserve null for the state for legacy callers, but the transient\n    // field should be undefined if not present to be consistent with the\n    // code path below.\n    return [null, undefined];\n  }\n  const {\n    transients,\n    ...state\n  } = transientState;\n  return [state, transients];\n}\n/**\r\n * WithError\r\n *\r\n * Augment a State instance with transient error information.\r\n */\nfunction WithError(state, errorType, payload) {\n  const error = {\n    type: errorType,\n    payload\n  };\n  return {\n    ...state,\n    transients: {\n      error\n    }\n  };\n}\n/**\r\n * Middleware for processing TransientState associated with the reducer\r\n * returned by CreateGameReducer.\r\n * This should pretty much be used everywhere you want realistic state\r\n * transitions and error handling.\r\n */\nconst TransientHandlingMiddleware = store => next => action => {\n  const result = next(action);\n  switch (action.type) {\n    case STRIP_TRANSIENTS:\n      {\n        return result;\n      }\n    default:\n      {\n        const [, transients] = ExtractTransients(store.getState());\n        if (typeof transients !== 'undefined') {\n          store.dispatch(stripTransients());\n          // Dev Note: If parent middleware needs to correlate the spawned\n          // StripTransients action to the triggering action, instrument here.\n          //\n          // This is a bit tricky; for more details, see:\n          //   https://github.com/boardgameio/boardgame.io/pull/940#discussion_r636200648\n          return {\n            ...result,\n            transients\n          };\n        }\n        return result;\n      }\n  }\n};\n/**\r\n * CreateGameReducer\r\n *\r\n * Creates the main game state reducer.\r\n */\nfunction CreateGameReducer(_ref20) {\n  let {\n    game,\n    isClient\n  } = _ref20;\n  game = ProcessGameConfig(game);\n  /**\r\n   * GameReducer\r\n   *\r\n   * Redux reducer that maintains the overall game state.\r\n   * @param {object} state - The state before the action.\r\n   * @param {object} action - A Redux action.\r\n   */\n  return function () {\n    let stateWithTransients = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let action = arguments.length > 1 ? arguments[1] : undefined;\n    let [state /*, transients */] = ExtractTransients(stateWithTransients);\n    switch (action.type) {\n      case STRIP_TRANSIENTS:\n        {\n          // This action indicates that transient metadata in the state has been\n          // consumed and should now be stripped from the state..\n          return state;\n        }\n      case GAME_EVENT:\n        {\n          state = {\n            ...state,\n            deltalog: []\n          };\n          // Process game events only on the server.\n          // These events like `endTurn` typically\n          // contain code that may rely on secret state\n          // and cannot be computed on the client.\n          if (isClient) {\n            return state;\n          }\n          // Disallow events once the game is over.\n          if (state.ctx.gameover !== undefined) {\n            error(`cannot call event after game end`);\n            return WithError(state, ActionErrorType.GameOver);\n          }\n          // Ignore the event if the player isn't active.\n          if (actionHasPlayerID(action) && !game.flow.isPlayerActive(state.G, state.ctx, action.payload.playerID)) {\n            error(`disallowed event: ${action.payload.type}`);\n            return WithError(state, ActionErrorType.InactivePlayer);\n          }\n          // Execute plugins.\n          state = Enhance(state, {\n            game,\n            isClient: false,\n            playerID: action.payload.playerID\n          });\n          // Process event.\n          let newState = game.flow.processEvent(state, action);\n          // Execute plugins.\n          let stateWithError;\n          [newState, stateWithError] = flushAndValidatePlugins(newState, state, {\n            game,\n            isClient: false\n          });\n          if (stateWithError) return stateWithError;\n          // Update undo / redo state.\n          newState = updateUndoRedoState(newState, {\n            game,\n            action\n          });\n          return {\n            ...newState,\n            _stateID: state._stateID + 1\n          };\n        }\n      case MAKE_MOVE:\n        {\n          const oldState = state = {\n            ...state,\n            deltalog: []\n          };\n          // Check whether the move is allowed at this time.\n          const move = game.flow.getMove(state.ctx, action.payload.type, action.payload.playerID || state.ctx.currentPlayer);\n          if (move === null) {\n            error(`disallowed move: ${action.payload.type}`);\n            return WithError(state, ActionErrorType.UnavailableMove);\n          }\n          // Don't run move on client if move says so.\n          if (isClient && move.client === false) {\n            return state;\n          }\n          // Disallow moves once the game is over.\n          if (state.ctx.gameover !== undefined) {\n            error(`cannot make move after game end`);\n            return WithError(state, ActionErrorType.GameOver);\n          }\n          // Ignore the move if the player isn't active.\n          if (actionHasPlayerID(action) && !game.flow.isPlayerActive(state.G, state.ctx, action.payload.playerID)) {\n            error(`disallowed move: ${action.payload.type}`);\n            return WithError(state, ActionErrorType.InactivePlayer);\n          }\n          // Execute plugins.\n          state = Enhance(state, {\n            game,\n            isClient,\n            playerID: action.payload.playerID\n          });\n          // Process the move.\n          const G = game.processMove(state, action.payload);\n          // The game declared the move as invalid.\n          if (G === INVALID_MOVE) {\n            error(`invalid move: ${action.payload.type} args: ${action.payload.args}`);\n            // TODO(#723): Marshal a nice error payload with the processed move.\n            return WithError(state, ActionErrorType.InvalidMove);\n          }\n          const newState = {\n            ...state,\n            G\n          };\n          // Some plugin indicated that it is not suitable to be\n          // materialized on the client (and must wait for the server\n          // response instead).\n          if (isClient && NoClient(newState, {\n            game\n          })) {\n            return state;\n          }\n          state = newState;\n          // If we're on the client, just process the move\n          // and no triggers in multiplayer mode.\n          // These will be processed on the server, which\n          // will send back a state update.\n          if (isClient) {\n            let stateWithError;\n            [state, stateWithError] = flushAndValidatePlugins(state, oldState, {\n              game,\n              isClient: true\n            });\n            if (stateWithError) return stateWithError;\n            return {\n              ...state,\n              _stateID: state._stateID + 1\n            };\n          }\n          // On the server, construct the deltalog.\n          state = initializeDeltalog(state, action, move);\n          // Allow the flow reducer to process any triggers that happen after moves.\n          state = game.flow.processMove(state, action.payload);\n          let stateWithError;\n          [state, stateWithError] = flushAndValidatePlugins(state, oldState, {\n            game\n          });\n          if (stateWithError) return stateWithError;\n          // Update undo / redo state.\n          state = updateUndoRedoState(state, {\n            game,\n            action\n          });\n          return {\n            ...state,\n            _stateID: state._stateID + 1\n          };\n        }\n      case RESET:\n      case UPDATE:\n      case SYNC:\n        {\n          return action.state;\n        }\n      case UNDO:\n        {\n          state = {\n            ...state,\n            deltalog: []\n          };\n          if (game.disableUndo) {\n            error('Undo is not enabled');\n            return WithError(state, ActionErrorType.ActionDisabled);\n          }\n          const {\n            G,\n            ctx,\n            _undo,\n            _redo,\n            _stateID\n          } = state;\n          if (_undo.length < 2) {\n            error(`No moves to undo`);\n            return WithError(state, ActionErrorType.ActionInvalid);\n          }\n          const last = _undo[_undo.length - 1];\n          const restore = _undo[_undo.length - 2];\n          // Only allow players to undo their own moves.\n          if (actionHasPlayerID(action) && action.payload.playerID !== last.playerID) {\n            error(`Cannot undo other players' moves`);\n            return WithError(state, ActionErrorType.ActionInvalid);\n          }\n          // If undoing a move, check it is undoable.\n          if (last.moveType) {\n            const lastMove = game.flow.getMove(restore.ctx, last.moveType, last.playerID);\n            if (!CanUndoMove(G, ctx, lastMove)) {\n              error(`Move cannot be undone`);\n              return WithError(state, ActionErrorType.ActionInvalid);\n            }\n          }\n          state = initializeDeltalog(state, action);\n          return {\n            ...state,\n            G: restore.G,\n            ctx: restore.ctx,\n            plugins: restore.plugins,\n            _stateID: _stateID + 1,\n            _undo: _undo.slice(0, -1),\n            _redo: [last, ..._redo]\n          };\n        }\n      case REDO:\n        {\n          state = {\n            ...state,\n            deltalog: []\n          };\n          if (game.disableUndo) {\n            error('Redo is not enabled');\n            return WithError(state, ActionErrorType.ActionDisabled);\n          }\n          const {\n            _undo,\n            _redo,\n            _stateID\n          } = state;\n          if (_redo.length === 0) {\n            error(`No moves to redo`);\n            return WithError(state, ActionErrorType.ActionInvalid);\n          }\n          const first = _redo[0];\n          // Only allow players to redo their own undos.\n          if (actionHasPlayerID(action) && action.payload.playerID !== first.playerID) {\n            error(`Cannot redo other players' moves`);\n            return WithError(state, ActionErrorType.ActionInvalid);\n          }\n          state = initializeDeltalog(state, action);\n          return {\n            ...state,\n            G: first.G,\n            ctx: first.ctx,\n            plugins: first.plugins,\n            _stateID: _stateID + 1,\n            _undo: [..._undo, first],\n            _redo: _redo.slice(1)\n          };\n        }\n      case PLUGIN:\n        {\n          // TODO(#723): Expose error semantics to plugin processing.\n          return ProcessAction(state, action, {\n            game\n          });\n        }\n      case PATCH:\n        {\n          const oldState = state;\n          const newState = JSON.parse(JSON.stringify(oldState));\n          const patchError = applyPatch(newState, action.patch);\n          const hasError = patchError.some(entry => entry !== null);\n          if (hasError) {\n            error(`Patch ${JSON.stringify(action.patch)} apply failed`);\n            return WithError(oldState, UpdateErrorType.PatchFailed, patchError);\n          } else {\n            return newState;\n          }\n        }\n      default:\n        {\n          return state;\n        }\n    }\n  };\n}\nexport { CreateGameReducer as C, IsLongFormMove as I, ProcessGameConfig as P, TransientHandlingMiddleware as T };","map":{"version":3,"names":["e","error","G","GameMethod","a","GetAPIs","T","TurnOrder","b","supportDeprecatedMoveLimit","S","Stage","c","SetActivePlayers","i","info","F","FnWrap","I","InitTurnOrderState","U","UpdateTurnOrderState","d","UpdateActivePlayersOnceEmpty","g","gameEvent","P","PATCH","f","PLUGIN","h","ProcessAction","R","REDO","j","UNDO","k","SYNC","l","UPDATE","m","RESET","M","MAKE_MOVE","E","Enhance","n","INVALID_MOVE","N","NoClient","o","GAME_EVENT","p","STRIP_TRANSIENTS","q","FlushAndValidate","r","stripTransients","applyPatch","Flow","_ref","moves","phases","endIf","onEnd","turn","events","plugins","undefined","_ref2","phaseMap","moveMap","moveNames","Set","startingPhase","Object","keys","forEach","name","add","HookWrapper","hook","hookType","withPlugins","state","pluginAPIs","ctx","playerID","TriggerWrapper","trigger","wrapped","GAME_ON_END","phase","phaseConfig","start","move","onBegin","_ref3","_ref4","order","DEFAULT","_ref5","_ref6","onMove","_ref7","stages","stage","stageConfig","key","PHASE_ON_BEGIN","PHASE_ON_END","TURN_ON_MOVE","TURN_ON_BEGIN","TURN_ON_END","next","GetPhase","OnMove","Process","phasesEnded","turnsEnded","length","fn","arg","rest","EndPhase","clear","has","EndGame","shouldEndGame","ShouldEndGame","push","automatic","shouldEndPhase","ShouldEndPhase","UpdateStage","UpdateActivePlayers","includes","shouldEndTurn","ShouldEndTurn","EndTurn","StartGame","_ref8","StartPhase","_ref9","StartTurn","_ref10","currentPlayer","activePlayers","numMoves","_prevActivePlayers","_undo","_redo","UpdatePhase","_ref11","UpdateTurn","_ref12","endPhase","newCtx","_ref13","NULL","_activePlayersMinMoves","_activePlayersMaxMoves","_activePlayersNumMoves","minMoves","maxMoves","_ref14","currentPlayerMoves","_ref15","gameover","_ref16","initialTurn","force","action","_stateID","logEntry","deltalog","_ref17","remove","playOrder","filter","playOrderPos","EndStage","_ref18","playerInStage","GetMove","ProcessMove","type","shouldCount","noLimit","SetStageEvent","EndStageEvent","SetActivePlayersEvent","_playerID","SetPhaseEvent","newPhase","EndPhaseEvent","EndTurnEvent","PassEvent","EndGameEvent","eventHandlers","endStage","setStage","endTurn","pass","setPhase","endGame","setActivePlayers","enabledEventNames","ProcessEvent","args","payload","Array","isArray","IsPlayerActive","_G","numPlayers","from","map","_","init","isPlayerActive","eventNames","values","processMove","processEvent","getMove","IsProcessed","game","ProcessGameConfig","deltaState","disableUndo","setup","playerView","_ref19","plugin","Error","flow","pluginNames","moveFn","IsLongFormMove","Function","MOVE","context","UpdateErrorType","ActionErrorType","actionHasPlayerID","CanUndoMove","HasUndoable","undoable","IsFunction","updateUndoRedoState","opts","undoEntry","moveType","initializeDeltalog","pluginLogMetadata","log","data","metadata","redact","flushAndValidatePlugins","oldState","pluginOpts","newState","isInvalid","WithError","PluginActionInvalid","ExtractTransients","transientState","transients","errorType","TransientHandlingMiddleware","store","result","getState","dispatch","CreateGameReducer","_ref20","isClient","stateWithTransients","arguments","GameOver","InactivePlayer","stateWithError","UnavailableMove","client","InvalidMove","ActionDisabled","ActionInvalid","last","restore","lastMove","slice","first","JSON","parse","stringify","patchError","patch","hasError","some","entry","PatchFailed","C"],"sources":["/Users/aaron/Desktop/School/488_CMPSC/GUI-based-Web-Game-with-Cloud-Native-Infrastructure-Backend 3-21 copy/upwardmobility/node_modules/boardgame.io/dist/esm/reducer-24ea3e4c.js"],"sourcesContent":["import { e as error, G as GameMethod, a as GetAPIs, T as TurnOrder, b as supportDeprecatedMoveLimit, S as Stage, c as SetActivePlayers, i as info, F as FnWrap, I as InitTurnOrderState, U as UpdateTurnOrderState, d as UpdateActivePlayersOnceEmpty, g as gameEvent, P as PATCH, f as PLUGIN, h as ProcessAction, R as REDO, j as UNDO, k as SYNC, l as UPDATE, m as RESET, M as MAKE_MOVE, E as Enhance, n as INVALID_MOVE, N as NoClient, o as GAME_EVENT, p as STRIP_TRANSIENTS, q as FlushAndValidate, r as stripTransients } from './turn-order-8cc4909b.js';\nimport { applyPatch } from 'rfc6902';\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Flow\r\n *\r\n * Creates a reducer that updates ctx (analogous to how moves update G).\r\n */\r\nfunction Flow({ moves, phases, endIf, onEnd, turn, events, plugins, }) {\r\n    // Attach defaults.\r\n    if (moves === undefined) {\r\n        moves = {};\r\n    }\r\n    if (events === undefined) {\r\n        events = {};\r\n    }\r\n    if (plugins === undefined) {\r\n        plugins = [];\r\n    }\r\n    if (phases === undefined) {\r\n        phases = {};\r\n    }\r\n    if (!endIf)\r\n        endIf = () => undefined;\r\n    if (!onEnd)\r\n        onEnd = ({ G }) => G;\r\n    if (!turn)\r\n        turn = {};\r\n    const phaseMap = { ...phases };\r\n    if ('' in phaseMap) {\r\n        error('cannot specify phase with empty name');\r\n    }\r\n    phaseMap[''] = {};\r\n    const moveMap = {};\r\n    const moveNames = new Set();\r\n    let startingPhase = null;\r\n    Object.keys(moves).forEach((name) => moveNames.add(name));\r\n    const HookWrapper = (hook, hookType) => {\r\n        const withPlugins = FnWrap(hook, hookType, plugins);\r\n        return (state) => {\r\n            const pluginAPIs = GetAPIs(state);\r\n            return withPlugins({\r\n                ...pluginAPIs,\r\n                G: state.G,\r\n                ctx: state.ctx,\r\n                playerID: state.playerID,\r\n            });\r\n        };\r\n    };\r\n    const TriggerWrapper = (trigger) => {\r\n        return (state) => {\r\n            const pluginAPIs = GetAPIs(state);\r\n            return trigger({\r\n                ...pluginAPIs,\r\n                G: state.G,\r\n                ctx: state.ctx,\r\n            });\r\n        };\r\n    };\r\n    const wrapped = {\r\n        onEnd: HookWrapper(onEnd, GameMethod.GAME_ON_END),\r\n        endIf: TriggerWrapper(endIf),\r\n    };\r\n    for (const phase in phaseMap) {\r\n        const phaseConfig = phaseMap[phase];\r\n        if (phaseConfig.start === true) {\r\n            startingPhase = phase;\r\n        }\r\n        if (phaseConfig.moves !== undefined) {\r\n            for (const move of Object.keys(phaseConfig.moves)) {\r\n                moveMap[phase + '.' + move] = phaseConfig.moves[move];\r\n                moveNames.add(move);\r\n            }\r\n        }\r\n        if (phaseConfig.endIf === undefined) {\r\n            phaseConfig.endIf = () => undefined;\r\n        }\r\n        if (phaseConfig.onBegin === undefined) {\r\n            phaseConfig.onBegin = ({ G }) => G;\r\n        }\r\n        if (phaseConfig.onEnd === undefined) {\r\n            phaseConfig.onEnd = ({ G }) => G;\r\n        }\r\n        if (phaseConfig.turn === undefined) {\r\n            phaseConfig.turn = turn;\r\n        }\r\n        if (phaseConfig.turn.order === undefined) {\r\n            phaseConfig.turn.order = TurnOrder.DEFAULT;\r\n        }\r\n        if (phaseConfig.turn.onBegin === undefined) {\r\n            phaseConfig.turn.onBegin = ({ G }) => G;\r\n        }\r\n        if (phaseConfig.turn.onEnd === undefined) {\r\n            phaseConfig.turn.onEnd = ({ G }) => G;\r\n        }\r\n        if (phaseConfig.turn.endIf === undefined) {\r\n            phaseConfig.turn.endIf = () => false;\r\n        }\r\n        if (phaseConfig.turn.onMove === undefined) {\r\n            phaseConfig.turn.onMove = ({ G }) => G;\r\n        }\r\n        if (phaseConfig.turn.stages === undefined) {\r\n            phaseConfig.turn.stages = {};\r\n        }\r\n        // turns previously treated moveLimit as both minMoves and maxMoves, this behaviour is kept intentionally\r\n        supportDeprecatedMoveLimit(phaseConfig.turn, true);\r\n        for (const stage in phaseConfig.turn.stages) {\r\n            const stageConfig = phaseConfig.turn.stages[stage];\r\n            const moves = stageConfig.moves || {};\r\n            for (const move of Object.keys(moves)) {\r\n                const key = phase + '.' + stage + '.' + move;\r\n                moveMap[key] = moves[move];\r\n                moveNames.add(move);\r\n            }\r\n        }\r\n        phaseConfig.wrapped = {\r\n            onBegin: HookWrapper(phaseConfig.onBegin, GameMethod.PHASE_ON_BEGIN),\r\n            onEnd: HookWrapper(phaseConfig.onEnd, GameMethod.PHASE_ON_END),\r\n            endIf: TriggerWrapper(phaseConfig.endIf),\r\n        };\r\n        phaseConfig.turn.wrapped = {\r\n            onMove: HookWrapper(phaseConfig.turn.onMove, GameMethod.TURN_ON_MOVE),\r\n            onBegin: HookWrapper(phaseConfig.turn.onBegin, GameMethod.TURN_ON_BEGIN),\r\n            onEnd: HookWrapper(phaseConfig.turn.onEnd, GameMethod.TURN_ON_END),\r\n            endIf: TriggerWrapper(phaseConfig.turn.endIf),\r\n        };\r\n        if (typeof phaseConfig.next !== 'function') {\r\n            const { next } = phaseConfig;\r\n            phaseConfig.next = () => next || null;\r\n        }\r\n        phaseConfig.wrapped.next = TriggerWrapper(phaseConfig.next);\r\n    }\r\n    function GetPhase(ctx) {\r\n        return ctx.phase ? phaseMap[ctx.phase] : phaseMap[''];\r\n    }\r\n    function OnMove(state) {\r\n        return state;\r\n    }\r\n    function Process(state, events) {\r\n        const phasesEnded = new Set();\r\n        const turnsEnded = new Set();\r\n        for (let i = 0; i < events.length; i++) {\r\n            const { fn, arg, ...rest } = events[i];\r\n            // Detect a loop of EndPhase calls.\r\n            // This could potentially even be an infinite loop\r\n            // if the endIf condition of each phase blindly\r\n            // returns true. The moment we detect a single\r\n            // loop, we just bail out of all phases.\r\n            if (fn === EndPhase) {\r\n                turnsEnded.clear();\r\n                const phase = state.ctx.phase;\r\n                if (phasesEnded.has(phase)) {\r\n                    const ctx = { ...state.ctx, phase: null };\r\n                    return { ...state, ctx };\r\n                }\r\n                phasesEnded.add(phase);\r\n            }\r\n            // Process event.\r\n            const next = [];\r\n            state = fn(state, {\r\n                ...rest,\r\n                arg,\r\n                next,\r\n            });\r\n            if (fn === EndGame) {\r\n                break;\r\n            }\r\n            // Check if we should end the game.\r\n            const shouldEndGame = ShouldEndGame(state);\r\n            if (shouldEndGame) {\r\n                events.push({\r\n                    fn: EndGame,\r\n                    arg: shouldEndGame,\r\n                    turn: state.ctx.turn,\r\n                    phase: state.ctx.phase,\r\n                    automatic: true,\r\n                });\r\n                continue;\r\n            }\r\n            // Check if we should end the phase.\r\n            const shouldEndPhase = ShouldEndPhase(state);\r\n            if (shouldEndPhase) {\r\n                events.push({\r\n                    fn: EndPhase,\r\n                    arg: shouldEndPhase,\r\n                    turn: state.ctx.turn,\r\n                    phase: state.ctx.phase,\r\n                    automatic: true,\r\n                });\r\n                continue;\r\n            }\r\n            // Check if we should end the turn.\r\n            if ([OnMove, UpdateStage, UpdateActivePlayers].includes(fn)) {\r\n                const shouldEndTurn = ShouldEndTurn(state);\r\n                if (shouldEndTurn) {\r\n                    events.push({\r\n                        fn: EndTurn,\r\n                        arg: shouldEndTurn,\r\n                        turn: state.ctx.turn,\r\n                        phase: state.ctx.phase,\r\n                        automatic: true,\r\n                    });\r\n                    continue;\r\n                }\r\n            }\r\n            events.push(...next);\r\n        }\r\n        return state;\r\n    }\r\n    ///////////\r\n    // Start //\r\n    ///////////\r\n    function StartGame(state, { next }) {\r\n        next.push({ fn: StartPhase });\r\n        return state;\r\n    }\r\n    function StartPhase(state, { next }) {\r\n        let { G, ctx } = state;\r\n        const phaseConfig = GetPhase(ctx);\r\n        // Run any phase setup code provided by the user.\r\n        G = phaseConfig.wrapped.onBegin(state);\r\n        next.push({ fn: StartTurn });\r\n        return { ...state, G, ctx };\r\n    }\r\n    function StartTurn(state, { currentPlayer }) {\r\n        let { ctx } = state;\r\n        const phaseConfig = GetPhase(ctx);\r\n        // Initialize the turn order state.\r\n        if (currentPlayer) {\r\n            ctx = { ...ctx, currentPlayer };\r\n            if (phaseConfig.turn.activePlayers) {\r\n                ctx = SetActivePlayers(ctx, phaseConfig.turn.activePlayers);\r\n            }\r\n        }\r\n        else {\r\n            // This is only called at the beginning of the phase\r\n            // when there is no currentPlayer yet.\r\n            ctx = InitTurnOrderState(state, phaseConfig.turn);\r\n        }\r\n        const turn = ctx.turn + 1;\r\n        ctx = { ...ctx, turn, numMoves: 0, _prevActivePlayers: [] };\r\n        const G = phaseConfig.turn.wrapped.onBegin({ ...state, ctx });\r\n        return { ...state, G, ctx, _undo: [], _redo: [] };\r\n    }\r\n    ////////////\r\n    // Update //\r\n    ////////////\r\n    function UpdatePhase(state, { arg, next, phase }) {\r\n        const phaseConfig = GetPhase({ phase });\r\n        let { ctx } = state;\r\n        if (arg && arg.next) {\r\n            if (arg.next in phaseMap) {\r\n                ctx = { ...ctx, phase: arg.next };\r\n            }\r\n            else {\r\n                error('invalid phase: ' + arg.next);\r\n                return state;\r\n            }\r\n        }\r\n        else {\r\n            ctx = { ...ctx, phase: phaseConfig.wrapped.next(state) || null };\r\n        }\r\n        state = { ...state, ctx };\r\n        // Start the new phase.\r\n        next.push({ fn: StartPhase });\r\n        return state;\r\n    }\r\n    function UpdateTurn(state, { arg, currentPlayer, next }) {\r\n        let { G, ctx } = state;\r\n        const phaseConfig = GetPhase(ctx);\r\n        // Update turn order state.\r\n        const { endPhase, ctx: newCtx } = UpdateTurnOrderState(state, currentPlayer, phaseConfig.turn, arg);\r\n        ctx = newCtx;\r\n        state = { ...state, G, ctx };\r\n        if (endPhase) {\r\n            next.push({ fn: EndPhase, turn: ctx.turn, phase: ctx.phase });\r\n        }\r\n        else {\r\n            next.push({ fn: StartTurn, currentPlayer: ctx.currentPlayer });\r\n        }\r\n        return state;\r\n    }\r\n    function UpdateStage(state, { arg, playerID }) {\r\n        if (typeof arg === 'string' || arg === Stage.NULL) {\r\n            arg = { stage: arg };\r\n        }\r\n        if (typeof arg !== 'object')\r\n            return state;\r\n        // `arg` should be of type `StageArg`, loose typing as `any` here for historic reasons\r\n        // stages previously did not enforce minMoves, this behaviour is kept intentionally\r\n        supportDeprecatedMoveLimit(arg);\r\n        let { ctx } = state;\r\n        let { activePlayers, _activePlayersMinMoves, _activePlayersMaxMoves, _activePlayersNumMoves, } = ctx;\r\n        // Checking if stage is valid, even Stage.NULL\r\n        if (arg.stage !== undefined) {\r\n            if (activePlayers === null) {\r\n                activePlayers = {};\r\n            }\r\n            activePlayers[playerID] = arg.stage;\r\n            _activePlayersNumMoves[playerID] = 0;\r\n            if (arg.minMoves) {\r\n                if (_activePlayersMinMoves === null) {\r\n                    _activePlayersMinMoves = {};\r\n                }\r\n                _activePlayersMinMoves[playerID] = arg.minMoves;\r\n            }\r\n            if (arg.maxMoves) {\r\n                if (_activePlayersMaxMoves === null) {\r\n                    _activePlayersMaxMoves = {};\r\n                }\r\n                _activePlayersMaxMoves[playerID] = arg.maxMoves;\r\n            }\r\n        }\r\n        ctx = {\r\n            ...ctx,\r\n            activePlayers,\r\n            _activePlayersMinMoves,\r\n            _activePlayersMaxMoves,\r\n            _activePlayersNumMoves,\r\n        };\r\n        return { ...state, ctx };\r\n    }\r\n    function UpdateActivePlayers(state, { arg }) {\r\n        return { ...state, ctx: SetActivePlayers(state.ctx, arg) };\r\n    }\r\n    ///////////////\r\n    // ShouldEnd //\r\n    ///////////////\r\n    function ShouldEndGame(state) {\r\n        return wrapped.endIf(state);\r\n    }\r\n    function ShouldEndPhase(state) {\r\n        const phaseConfig = GetPhase(state.ctx);\r\n        return phaseConfig.wrapped.endIf(state);\r\n    }\r\n    function ShouldEndTurn(state) {\r\n        const phaseConfig = GetPhase(state.ctx);\r\n        // End the turn if the required number of moves has been made.\r\n        const currentPlayerMoves = state.ctx.numMoves || 0;\r\n        if (phaseConfig.turn.maxMoves &&\r\n            currentPlayerMoves >= phaseConfig.turn.maxMoves) {\r\n            return true;\r\n        }\r\n        return phaseConfig.turn.wrapped.endIf(state);\r\n    }\r\n    /////////\r\n    // End //\r\n    /////////\r\n    function EndGame(state, { arg, phase }) {\r\n        state = EndPhase(state, { phase });\r\n        if (arg === undefined) {\r\n            arg = true;\r\n        }\r\n        state = { ...state, ctx: { ...state.ctx, gameover: arg } };\r\n        // Run game end hook.\r\n        const G = wrapped.onEnd(state);\r\n        return { ...state, G };\r\n    }\r\n    function EndPhase(state, { arg, next, turn: initialTurn, automatic }) {\r\n        // End the turn first.\r\n        state = EndTurn(state, { turn: initialTurn, force: true, automatic: true });\r\n        const { phase, turn } = state.ctx;\r\n        if (next) {\r\n            next.push({ fn: UpdatePhase, arg, phase });\r\n        }\r\n        // If we aren't in a phase, there is nothing else to do.\r\n        if (phase === null) {\r\n            return state;\r\n        }\r\n        // Run any cleanup code for the phase that is about to end.\r\n        const phaseConfig = GetPhase(state.ctx);\r\n        const G = phaseConfig.wrapped.onEnd(state);\r\n        // Reset the phase.\r\n        const ctx = { ...state.ctx, phase: null };\r\n        // Add log entry.\r\n        const action = gameEvent('endPhase', arg);\r\n        const { _stateID } = state;\r\n        const logEntry = { action, _stateID, turn, phase };\r\n        if (automatic)\r\n            logEntry.automatic = true;\r\n        const deltalog = [...(state.deltalog || []), logEntry];\r\n        return { ...state, G, ctx, deltalog };\r\n    }\r\n    function EndTurn(state, { arg, next, turn: initialTurn, force, automatic, playerID }) {\r\n        // This is not the turn that EndTurn was originally\r\n        // called for. The turn was probably ended some other way.\r\n        if (initialTurn !== state.ctx.turn) {\r\n            return state;\r\n        }\r\n        const { currentPlayer, numMoves, phase, turn } = state.ctx;\r\n        const phaseConfig = GetPhase(state.ctx);\r\n        // Prevent ending the turn if minMoves haven't been reached.\r\n        const currentPlayerMoves = numMoves || 0;\r\n        if (!force &&\r\n            phaseConfig.turn.minMoves &&\r\n            currentPlayerMoves < phaseConfig.turn.minMoves) {\r\n            info(`cannot end turn before making ${phaseConfig.turn.minMoves} moves`);\r\n            return state;\r\n        }\r\n        // Run turn-end triggers.\r\n        const G = phaseConfig.turn.wrapped.onEnd(state);\r\n        if (next) {\r\n            next.push({ fn: UpdateTurn, arg, currentPlayer });\r\n        }\r\n        // Reset activePlayers.\r\n        let ctx = { ...state.ctx, activePlayers: null };\r\n        // Remove player from playerOrder\r\n        if (arg && arg.remove) {\r\n            playerID = playerID || currentPlayer;\r\n            const playOrder = ctx.playOrder.filter((i) => i != playerID);\r\n            const playOrderPos = ctx.playOrderPos > playOrder.length - 1 ? 0 : ctx.playOrderPos;\r\n            ctx = { ...ctx, playOrder, playOrderPos };\r\n            if (playOrder.length === 0) {\r\n                next.push({ fn: EndPhase, turn, phase });\r\n                return state;\r\n            }\r\n        }\r\n        // Create log entry.\r\n        const action = gameEvent('endTurn', arg);\r\n        const { _stateID } = state;\r\n        const logEntry = { action, _stateID, turn, phase };\r\n        if (automatic)\r\n            logEntry.automatic = true;\r\n        const deltalog = [...(state.deltalog || []), logEntry];\r\n        return { ...state, G, ctx, deltalog, _undo: [], _redo: [] };\r\n    }\r\n    function EndStage(state, { arg, next, automatic, playerID }) {\r\n        playerID = playerID || state.ctx.currentPlayer;\r\n        let { ctx, _stateID } = state;\r\n        let { activePlayers, _activePlayersNumMoves, _activePlayersMinMoves, _activePlayersMaxMoves, phase, turn, } = ctx;\r\n        const playerInStage = activePlayers !== null && playerID in activePlayers;\r\n        const phaseConfig = GetPhase(ctx);\r\n        if (!arg && playerInStage) {\r\n            const stage = phaseConfig.turn.stages[activePlayers[playerID]];\r\n            if (stage && stage.next) {\r\n                arg = stage.next;\r\n            }\r\n        }\r\n        // Checking if arg is a valid stage, even Stage.NULL\r\n        if (next) {\r\n            next.push({ fn: UpdateStage, arg, playerID });\r\n        }\r\n        // If player isn’t in a stage, there is nothing else to do.\r\n        if (!playerInStage)\r\n            return state;\r\n        // Prevent ending the stage if minMoves haven't been reached.\r\n        const currentPlayerMoves = _activePlayersNumMoves[playerID] || 0;\r\n        if (_activePlayersMinMoves &&\r\n            _activePlayersMinMoves[playerID] &&\r\n            currentPlayerMoves < _activePlayersMinMoves[playerID]) {\r\n            info(`cannot end stage before making ${_activePlayersMinMoves[playerID]} moves`);\r\n            return state;\r\n        }\r\n        // Remove player from activePlayers.\r\n        activePlayers = { ...activePlayers };\r\n        delete activePlayers[playerID];\r\n        if (_activePlayersMinMoves) {\r\n            // Remove player from _activePlayersMinMoves.\r\n            _activePlayersMinMoves = { ..._activePlayersMinMoves };\r\n            delete _activePlayersMinMoves[playerID];\r\n        }\r\n        if (_activePlayersMaxMoves) {\r\n            // Remove player from _activePlayersMaxMoves.\r\n            _activePlayersMaxMoves = { ..._activePlayersMaxMoves };\r\n            delete _activePlayersMaxMoves[playerID];\r\n        }\r\n        ctx = UpdateActivePlayersOnceEmpty({\r\n            ...ctx,\r\n            activePlayers,\r\n            _activePlayersMinMoves,\r\n            _activePlayersMaxMoves,\r\n        });\r\n        // Create log entry.\r\n        const action = gameEvent('endStage', arg);\r\n        const logEntry = { action, _stateID, turn, phase };\r\n        if (automatic)\r\n            logEntry.automatic = true;\r\n        const deltalog = [...(state.deltalog || []), logEntry];\r\n        return { ...state, ctx, deltalog };\r\n    }\r\n    /**\r\n     * Retrieves the relevant move that can be played by playerID.\r\n     *\r\n     * If ctx.activePlayers is set (i.e. one or more players are in some stage),\r\n     * then it attempts to find the move inside the stages config for\r\n     * that turn. If the stage for a player is '', then the player is\r\n     * allowed to make a move (as determined by the phase config), but\r\n     * isn't restricted to a particular set as defined in the stage config.\r\n     *\r\n     * If not, it then looks for the move inside the phase.\r\n     *\r\n     * If it doesn't find the move there, it looks at the global move definition.\r\n     *\r\n     * @param {object} ctx\r\n     * @param {string} name\r\n     * @param {string} playerID\r\n     */\r\n    function GetMove(ctx, name, playerID) {\r\n        const phaseConfig = GetPhase(ctx);\r\n        const stages = phaseConfig.turn.stages;\r\n        const { activePlayers } = ctx;\r\n        if (activePlayers &&\r\n            activePlayers[playerID] !== undefined &&\r\n            activePlayers[playerID] !== Stage.NULL &&\r\n            stages[activePlayers[playerID]] !== undefined &&\r\n            stages[activePlayers[playerID]].moves !== undefined) {\r\n            // Check if moves are defined for the player's stage.\r\n            const stage = stages[activePlayers[playerID]];\r\n            const moves = stage.moves;\r\n            if (name in moves) {\r\n                return moves[name];\r\n            }\r\n        }\r\n        else if (phaseConfig.moves) {\r\n            // Check if moves are defined for the current phase.\r\n            if (name in phaseConfig.moves) {\r\n                return phaseConfig.moves[name];\r\n            }\r\n        }\r\n        else if (name in moves) {\r\n            // Check for the move globally.\r\n            return moves[name];\r\n        }\r\n        return null;\r\n    }\r\n    function ProcessMove(state, action) {\r\n        const { playerID, type } = action;\r\n        const { currentPlayer, activePlayers, _activePlayersMaxMoves } = state.ctx;\r\n        const move = GetMove(state.ctx, type, playerID);\r\n        const shouldCount = !move || typeof move === 'function' || move.noLimit !== true;\r\n        let { numMoves, _activePlayersNumMoves } = state.ctx;\r\n        if (shouldCount) {\r\n            if (playerID === currentPlayer)\r\n                numMoves++;\r\n            if (activePlayers)\r\n                _activePlayersNumMoves[playerID]++;\r\n        }\r\n        state = {\r\n            ...state,\r\n            ctx: {\r\n                ...state.ctx,\r\n                numMoves,\r\n                _activePlayersNumMoves,\r\n            },\r\n        };\r\n        if (_activePlayersMaxMoves &&\r\n            _activePlayersNumMoves[playerID] >= _activePlayersMaxMoves[playerID]) {\r\n            state = EndStage(state, { playerID, automatic: true });\r\n        }\r\n        const phaseConfig = GetPhase(state.ctx);\r\n        const G = phaseConfig.turn.wrapped.onMove({ ...state, playerID });\r\n        state = { ...state, G };\r\n        const events = [{ fn: OnMove }];\r\n        return Process(state, events);\r\n    }\r\n    function SetStageEvent(state, playerID, arg) {\r\n        return Process(state, [{ fn: EndStage, arg, playerID }]);\r\n    }\r\n    function EndStageEvent(state, playerID) {\r\n        return Process(state, [{ fn: EndStage, playerID }]);\r\n    }\r\n    function SetActivePlayersEvent(state, _playerID, arg) {\r\n        return Process(state, [{ fn: UpdateActivePlayers, arg }]);\r\n    }\r\n    function SetPhaseEvent(state, _playerID, newPhase) {\r\n        return Process(state, [\r\n            {\r\n                fn: EndPhase,\r\n                phase: state.ctx.phase,\r\n                turn: state.ctx.turn,\r\n                arg: { next: newPhase },\r\n            },\r\n        ]);\r\n    }\r\n    function EndPhaseEvent(state) {\r\n        return Process(state, [\r\n            { fn: EndPhase, phase: state.ctx.phase, turn: state.ctx.turn },\r\n        ]);\r\n    }\r\n    function EndTurnEvent(state, _playerID, arg) {\r\n        return Process(state, [\r\n            { fn: EndTurn, turn: state.ctx.turn, phase: state.ctx.phase, arg },\r\n        ]);\r\n    }\r\n    function PassEvent(state, _playerID, arg) {\r\n        return Process(state, [\r\n            {\r\n                fn: EndTurn,\r\n                turn: state.ctx.turn,\r\n                phase: state.ctx.phase,\r\n                force: true,\r\n                arg,\r\n            },\r\n        ]);\r\n    }\r\n    function EndGameEvent(state, _playerID, arg) {\r\n        return Process(state, [\r\n            { fn: EndGame, turn: state.ctx.turn, phase: state.ctx.phase, arg },\r\n        ]);\r\n    }\r\n    const eventHandlers = {\r\n        endStage: EndStageEvent,\r\n        setStage: SetStageEvent,\r\n        endTurn: EndTurnEvent,\r\n        pass: PassEvent,\r\n        endPhase: EndPhaseEvent,\r\n        setPhase: SetPhaseEvent,\r\n        endGame: EndGameEvent,\r\n        setActivePlayers: SetActivePlayersEvent,\r\n    };\r\n    const enabledEventNames = [];\r\n    if (events.endTurn !== false) {\r\n        enabledEventNames.push('endTurn');\r\n    }\r\n    if (events.pass !== false) {\r\n        enabledEventNames.push('pass');\r\n    }\r\n    if (events.endPhase !== false) {\r\n        enabledEventNames.push('endPhase');\r\n    }\r\n    if (events.setPhase !== false) {\r\n        enabledEventNames.push('setPhase');\r\n    }\r\n    if (events.endGame !== false) {\r\n        enabledEventNames.push('endGame');\r\n    }\r\n    if (events.setActivePlayers !== false) {\r\n        enabledEventNames.push('setActivePlayers');\r\n    }\r\n    if (events.endStage !== false) {\r\n        enabledEventNames.push('endStage');\r\n    }\r\n    if (events.setStage !== false) {\r\n        enabledEventNames.push('setStage');\r\n    }\r\n    function ProcessEvent(state, action) {\r\n        const { type, playerID, args } = action.payload;\r\n        if (typeof eventHandlers[type] !== 'function')\r\n            return state;\r\n        return eventHandlers[type](state, playerID, ...(Array.isArray(args) ? args : [args]));\r\n    }\r\n    function IsPlayerActive(_G, ctx, playerID) {\r\n        if (ctx.activePlayers) {\r\n            return playerID in ctx.activePlayers;\r\n        }\r\n        return ctx.currentPlayer === playerID;\r\n    }\r\n    return {\r\n        ctx: (numPlayers) => ({\r\n            numPlayers,\r\n            turn: 0,\r\n            currentPlayer: '0',\r\n            playOrder: [...Array.from({ length: numPlayers })].map((_, i) => i + ''),\r\n            playOrderPos: 0,\r\n            phase: startingPhase,\r\n            activePlayers: null,\r\n        }),\r\n        init: (state) => {\r\n            return Process(state, [{ fn: StartGame }]);\r\n        },\r\n        isPlayerActive: IsPlayerActive,\r\n        eventHandlers,\r\n        eventNames: Object.keys(eventHandlers),\r\n        enabledEventNames,\r\n        moveMap,\r\n        moveNames: [...moveNames.values()],\r\n        processMove: ProcessMove,\r\n        processEvent: ProcessEvent,\r\n        getMove: GetMove,\r\n    };\r\n}\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\nfunction IsProcessed(game) {\r\n    return game.processMove !== undefined;\r\n}\r\n/**\r\n * Helper to generate the game move reducer. The returned\r\n * reducer has the following signature:\r\n *\r\n * (G, action, ctx) => {}\r\n *\r\n * You can roll your own if you like, or use any Redux\r\n * addon to generate such a reducer.\r\n *\r\n * The convention used in this framework is to\r\n * have action.type contain the name of the move, and\r\n * action.args contain any additional arguments as an\r\n * Array.\r\n */\r\nfunction ProcessGameConfig(game) {\r\n    // The Game() function has already been called on this\r\n    // config object, so just pass it through.\r\n    if (IsProcessed(game)) {\r\n        return game;\r\n    }\r\n    if (game.name === undefined)\r\n        game.name = 'default';\r\n    if (game.deltaState === undefined)\r\n        game.deltaState = false;\r\n    if (game.disableUndo === undefined)\r\n        game.disableUndo = false;\r\n    if (game.setup === undefined)\r\n        game.setup = () => ({});\r\n    if (game.moves === undefined)\r\n        game.moves = {};\r\n    if (game.playerView === undefined)\r\n        game.playerView = ({ G }) => G;\r\n    if (game.plugins === undefined)\r\n        game.plugins = [];\r\n    game.plugins.forEach((plugin) => {\r\n        if (plugin.name === undefined) {\r\n            throw new Error('Plugin missing name attribute');\r\n        }\r\n        if (plugin.name.includes(' ')) {\r\n            throw new Error(plugin.name + ': Plugin name must not include spaces');\r\n        }\r\n    });\r\n    if (game.name.includes(' ')) {\r\n        throw new Error(game.name + ': Game name must not include spaces');\r\n    }\r\n    const flow = Flow(game);\r\n    return {\r\n        ...game,\r\n        flow,\r\n        moveNames: flow.moveNames,\r\n        pluginNames: game.plugins.map((p) => p.name),\r\n        processMove: (state, action) => {\r\n            let moveFn = flow.getMove(state.ctx, action.type, action.playerID);\r\n            if (IsLongFormMove(moveFn)) {\r\n                moveFn = moveFn.move;\r\n            }\r\n            if (moveFn instanceof Function) {\r\n                const fn = FnWrap(moveFn, GameMethod.MOVE, game.plugins);\r\n                let args = [];\r\n                if (action.args !== undefined) {\r\n                    args = Array.isArray(action.args) ? action.args : [action.args];\r\n                }\r\n                const context = {\r\n                    ...GetAPIs(state),\r\n                    G: state.G,\r\n                    ctx: state.ctx,\r\n                    playerID: action.playerID,\r\n                };\r\n                return fn(context, ...args);\r\n            }\r\n            error(`invalid move object: ${action.type}`);\r\n            return state.G;\r\n        },\r\n    };\r\n}\r\nfunction IsLongFormMove(move) {\r\n    return move instanceof Object && move.move !== undefined;\r\n}\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\nvar UpdateErrorType;\r\n(function (UpdateErrorType) {\r\n    // The action’s credentials were missing or invalid\r\n    UpdateErrorType[\"UnauthorizedAction\"] = \"update/unauthorized_action\";\r\n    // The action’s matchID was not found\r\n    UpdateErrorType[\"MatchNotFound\"] = \"update/match_not_found\";\r\n    // Could not apply Patch operation (rfc6902).\r\n    UpdateErrorType[\"PatchFailed\"] = \"update/patch_failed\";\r\n})(UpdateErrorType || (UpdateErrorType = {}));\r\nvar ActionErrorType;\r\n(function (ActionErrorType) {\r\n    // The action contained a stale state ID\r\n    ActionErrorType[\"StaleStateId\"] = \"action/stale_state_id\";\r\n    // The requested move is unknown or not currently available\r\n    ActionErrorType[\"UnavailableMove\"] = \"action/unavailable_move\";\r\n    // The move declared it was invalid (INVALID_MOVE constant)\r\n    ActionErrorType[\"InvalidMove\"] = \"action/invalid_move\";\r\n    // The player making the action is not currently active\r\n    ActionErrorType[\"InactivePlayer\"] = \"action/inactive_player\";\r\n    // The game has finished\r\n    ActionErrorType[\"GameOver\"] = \"action/gameover\";\r\n    // The requested action is disabled (e.g. undo/redo, events)\r\n    ActionErrorType[\"ActionDisabled\"] = \"action/action_disabled\";\r\n    // The requested action is not currently possible\r\n    ActionErrorType[\"ActionInvalid\"] = \"action/action_invalid\";\r\n    // The requested action was declared invalid by a plugin\r\n    ActionErrorType[\"PluginActionInvalid\"] = \"action/plugin_invalid\";\r\n})(ActionErrorType || (ActionErrorType = {}));\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Check if the payload for the passed action contains a playerID.\r\n */\r\nconst actionHasPlayerID = (action) => action.payload.playerID !== null && action.payload.playerID !== undefined;\r\n/**\r\n * Returns true if a move can be undone.\r\n */\r\nconst CanUndoMove = (G, ctx, move) => {\r\n    function HasUndoable(move) {\r\n        return move.undoable !== undefined;\r\n    }\r\n    function IsFunction(undoable) {\r\n        return undoable instanceof Function;\r\n    }\r\n    if (!HasUndoable(move)) {\r\n        return true;\r\n    }\r\n    if (IsFunction(move.undoable)) {\r\n        return move.undoable({ G, ctx });\r\n    }\r\n    return move.undoable;\r\n};\r\n/**\r\n * Update the undo and redo stacks for a move or event.\r\n */\r\nfunction updateUndoRedoState(state, opts) {\r\n    if (opts.game.disableUndo)\r\n        return state;\r\n    const undoEntry = {\r\n        G: state.G,\r\n        ctx: state.ctx,\r\n        plugins: state.plugins,\r\n        playerID: opts.action.payload.playerID || state.ctx.currentPlayer,\r\n    };\r\n    if (opts.action.type === 'MAKE_MOVE') {\r\n        undoEntry.moveType = opts.action.payload.type;\r\n    }\r\n    return {\r\n        ...state,\r\n        _undo: [...state._undo, undoEntry],\r\n        // Always reset redo stack when making a move or event\r\n        _redo: [],\r\n    };\r\n}\r\n/**\r\n * Process state, adding the initial deltalog for this action.\r\n */\r\nfunction initializeDeltalog(state, action, move) {\r\n    // Create a log entry for this action.\r\n    const logEntry = {\r\n        action,\r\n        _stateID: state._stateID,\r\n        turn: state.ctx.turn,\r\n        phase: state.ctx.phase,\r\n    };\r\n    const pluginLogMetadata = state.plugins.log.data.metadata;\r\n    if (pluginLogMetadata !== undefined) {\r\n        logEntry.metadata = pluginLogMetadata;\r\n    }\r\n    if (typeof move === 'object' && move.redact === true) {\r\n        logEntry.redact = true;\r\n    }\r\n    else if (typeof move === 'object' && move.redact instanceof Function) {\r\n        logEntry.redact = move.redact({ G: state.G, ctx: state.ctx });\r\n    }\r\n    return {\r\n        ...state,\r\n        deltalog: [logEntry],\r\n    };\r\n}\r\n/**\r\n * Update plugin state after move/event & check if plugins consider the action to be valid.\r\n * @param state Current version of state in the reducer.\r\n * @param oldState State to revert to in case of error.\r\n * @param pluginOpts Plugin configuration options.\r\n * @returns Tuple of the new state updated after flushing plugins and the old\r\n * state augmented with an error if a plugin declared the action invalid.\r\n */\r\nfunction flushAndValidatePlugins(state, oldState, pluginOpts) {\r\n    const [newState, isInvalid] = FlushAndValidate(state, pluginOpts);\r\n    if (!isInvalid)\r\n        return [newState];\r\n    return [\r\n        newState,\r\n        WithError(oldState, ActionErrorType.PluginActionInvalid, isInvalid),\r\n    ];\r\n}\r\n/**\r\n * ExtractTransientsFromState\r\n *\r\n * Split out transients from the a TransientState\r\n */\r\nfunction ExtractTransients(transientState) {\r\n    if (!transientState) {\r\n        // We preserve null for the state for legacy callers, but the transient\r\n        // field should be undefined if not present to be consistent with the\r\n        // code path below.\r\n        return [null, undefined];\r\n    }\r\n    const { transients, ...state } = transientState;\r\n    return [state, transients];\r\n}\r\n/**\r\n * WithError\r\n *\r\n * Augment a State instance with transient error information.\r\n */\r\nfunction WithError(state, errorType, payload) {\r\n    const error = {\r\n        type: errorType,\r\n        payload,\r\n    };\r\n    return {\r\n        ...state,\r\n        transients: {\r\n            error,\r\n        },\r\n    };\r\n}\r\n/**\r\n * Middleware for processing TransientState associated with the reducer\r\n * returned by CreateGameReducer.\r\n * This should pretty much be used everywhere you want realistic state\r\n * transitions and error handling.\r\n */\r\nconst TransientHandlingMiddleware = (store) => (next) => (action) => {\r\n    const result = next(action);\r\n    switch (action.type) {\r\n        case STRIP_TRANSIENTS: {\r\n            return result;\r\n        }\r\n        default: {\r\n            const [, transients] = ExtractTransients(store.getState());\r\n            if (typeof transients !== 'undefined') {\r\n                store.dispatch(stripTransients());\r\n                // Dev Note: If parent middleware needs to correlate the spawned\r\n                // StripTransients action to the triggering action, instrument here.\r\n                //\r\n                // This is a bit tricky; for more details, see:\r\n                //   https://github.com/boardgameio/boardgame.io/pull/940#discussion_r636200648\r\n                return {\r\n                    ...result,\r\n                    transients,\r\n                };\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n};\r\n/**\r\n * CreateGameReducer\r\n *\r\n * Creates the main game state reducer.\r\n */\r\nfunction CreateGameReducer({ game, isClient, }) {\r\n    game = ProcessGameConfig(game);\r\n    /**\r\n     * GameReducer\r\n     *\r\n     * Redux reducer that maintains the overall game state.\r\n     * @param {object} state - The state before the action.\r\n     * @param {object} action - A Redux action.\r\n     */\r\n    return (stateWithTransients = null, action) => {\r\n        let [state /*, transients */] = ExtractTransients(stateWithTransients);\r\n        switch (action.type) {\r\n            case STRIP_TRANSIENTS: {\r\n                // This action indicates that transient metadata in the state has been\r\n                // consumed and should now be stripped from the state..\r\n                return state;\r\n            }\r\n            case GAME_EVENT: {\r\n                state = { ...state, deltalog: [] };\r\n                // Process game events only on the server.\r\n                // These events like `endTurn` typically\r\n                // contain code that may rely on secret state\r\n                // and cannot be computed on the client.\r\n                if (isClient) {\r\n                    return state;\r\n                }\r\n                // Disallow events once the game is over.\r\n                if (state.ctx.gameover !== undefined) {\r\n                    error(`cannot call event after game end`);\r\n                    return WithError(state, ActionErrorType.GameOver);\r\n                }\r\n                // Ignore the event if the player isn't active.\r\n                if (actionHasPlayerID(action) &&\r\n                    !game.flow.isPlayerActive(state.G, state.ctx, action.payload.playerID)) {\r\n                    error(`disallowed event: ${action.payload.type}`);\r\n                    return WithError(state, ActionErrorType.InactivePlayer);\r\n                }\r\n                // Execute plugins.\r\n                state = Enhance(state, {\r\n                    game,\r\n                    isClient: false,\r\n                    playerID: action.payload.playerID,\r\n                });\r\n                // Process event.\r\n                let newState = game.flow.processEvent(state, action);\r\n                // Execute plugins.\r\n                let stateWithError;\r\n                [newState, stateWithError] = flushAndValidatePlugins(newState, state, {\r\n                    game,\r\n                    isClient: false,\r\n                });\r\n                if (stateWithError)\r\n                    return stateWithError;\r\n                // Update undo / redo state.\r\n                newState = updateUndoRedoState(newState, { game, action });\r\n                return { ...newState, _stateID: state._stateID + 1 };\r\n            }\r\n            case MAKE_MOVE: {\r\n                const oldState = (state = { ...state, deltalog: [] });\r\n                // Check whether the move is allowed at this time.\r\n                const move = game.flow.getMove(state.ctx, action.payload.type, action.payload.playerID || state.ctx.currentPlayer);\r\n                if (move === null) {\r\n                    error(`disallowed move: ${action.payload.type}`);\r\n                    return WithError(state, ActionErrorType.UnavailableMove);\r\n                }\r\n                // Don't run move on client if move says so.\r\n                if (isClient && move.client === false) {\r\n                    return state;\r\n                }\r\n                // Disallow moves once the game is over.\r\n                if (state.ctx.gameover !== undefined) {\r\n                    error(`cannot make move after game end`);\r\n                    return WithError(state, ActionErrorType.GameOver);\r\n                }\r\n                // Ignore the move if the player isn't active.\r\n                if (actionHasPlayerID(action) &&\r\n                    !game.flow.isPlayerActive(state.G, state.ctx, action.payload.playerID)) {\r\n                    error(`disallowed move: ${action.payload.type}`);\r\n                    return WithError(state, ActionErrorType.InactivePlayer);\r\n                }\r\n                // Execute plugins.\r\n                state = Enhance(state, {\r\n                    game,\r\n                    isClient,\r\n                    playerID: action.payload.playerID,\r\n                });\r\n                // Process the move.\r\n                const G = game.processMove(state, action.payload);\r\n                // The game declared the move as invalid.\r\n                if (G === INVALID_MOVE) {\r\n                    error(`invalid move: ${action.payload.type} args: ${action.payload.args}`);\r\n                    // TODO(#723): Marshal a nice error payload with the processed move.\r\n                    return WithError(state, ActionErrorType.InvalidMove);\r\n                }\r\n                const newState = { ...state, G };\r\n                // Some plugin indicated that it is not suitable to be\r\n                // materialized on the client (and must wait for the server\r\n                // response instead).\r\n                if (isClient && NoClient(newState, { game })) {\r\n                    return state;\r\n                }\r\n                state = newState;\r\n                // If we're on the client, just process the move\r\n                // and no triggers in multiplayer mode.\r\n                // These will be processed on the server, which\r\n                // will send back a state update.\r\n                if (isClient) {\r\n                    let stateWithError;\r\n                    [state, stateWithError] = flushAndValidatePlugins(state, oldState, {\r\n                        game,\r\n                        isClient: true,\r\n                    });\r\n                    if (stateWithError)\r\n                        return stateWithError;\r\n                    return {\r\n                        ...state,\r\n                        _stateID: state._stateID + 1,\r\n                    };\r\n                }\r\n                // On the server, construct the deltalog.\r\n                state = initializeDeltalog(state, action, move);\r\n                // Allow the flow reducer to process any triggers that happen after moves.\r\n                state = game.flow.processMove(state, action.payload);\r\n                let stateWithError;\r\n                [state, stateWithError] = flushAndValidatePlugins(state, oldState, {\r\n                    game,\r\n                });\r\n                if (stateWithError)\r\n                    return stateWithError;\r\n                // Update undo / redo state.\r\n                state = updateUndoRedoState(state, { game, action });\r\n                return {\r\n                    ...state,\r\n                    _stateID: state._stateID + 1,\r\n                };\r\n            }\r\n            case RESET:\r\n            case UPDATE:\r\n            case SYNC: {\r\n                return action.state;\r\n            }\r\n            case UNDO: {\r\n                state = { ...state, deltalog: [] };\r\n                if (game.disableUndo) {\r\n                    error('Undo is not enabled');\r\n                    return WithError(state, ActionErrorType.ActionDisabled);\r\n                }\r\n                const { G, ctx, _undo, _redo, _stateID } = state;\r\n                if (_undo.length < 2) {\r\n                    error(`No moves to undo`);\r\n                    return WithError(state, ActionErrorType.ActionInvalid);\r\n                }\r\n                const last = _undo[_undo.length - 1];\r\n                const restore = _undo[_undo.length - 2];\r\n                // Only allow players to undo their own moves.\r\n                if (actionHasPlayerID(action) &&\r\n                    action.payload.playerID !== last.playerID) {\r\n                    error(`Cannot undo other players' moves`);\r\n                    return WithError(state, ActionErrorType.ActionInvalid);\r\n                }\r\n                // If undoing a move, check it is undoable.\r\n                if (last.moveType) {\r\n                    const lastMove = game.flow.getMove(restore.ctx, last.moveType, last.playerID);\r\n                    if (!CanUndoMove(G, ctx, lastMove)) {\r\n                        error(`Move cannot be undone`);\r\n                        return WithError(state, ActionErrorType.ActionInvalid);\r\n                    }\r\n                }\r\n                state = initializeDeltalog(state, action);\r\n                return {\r\n                    ...state,\r\n                    G: restore.G,\r\n                    ctx: restore.ctx,\r\n                    plugins: restore.plugins,\r\n                    _stateID: _stateID + 1,\r\n                    _undo: _undo.slice(0, -1),\r\n                    _redo: [last, ..._redo],\r\n                };\r\n            }\r\n            case REDO: {\r\n                state = { ...state, deltalog: [] };\r\n                if (game.disableUndo) {\r\n                    error('Redo is not enabled');\r\n                    return WithError(state, ActionErrorType.ActionDisabled);\r\n                }\r\n                const { _undo, _redo, _stateID } = state;\r\n                if (_redo.length === 0) {\r\n                    error(`No moves to redo`);\r\n                    return WithError(state, ActionErrorType.ActionInvalid);\r\n                }\r\n                const first = _redo[0];\r\n                // Only allow players to redo their own undos.\r\n                if (actionHasPlayerID(action) &&\r\n                    action.payload.playerID !== first.playerID) {\r\n                    error(`Cannot redo other players' moves`);\r\n                    return WithError(state, ActionErrorType.ActionInvalid);\r\n                }\r\n                state = initializeDeltalog(state, action);\r\n                return {\r\n                    ...state,\r\n                    G: first.G,\r\n                    ctx: first.ctx,\r\n                    plugins: first.plugins,\r\n                    _stateID: _stateID + 1,\r\n                    _undo: [..._undo, first],\r\n                    _redo: _redo.slice(1),\r\n                };\r\n            }\r\n            case PLUGIN: {\r\n                // TODO(#723): Expose error semantics to plugin processing.\r\n                return ProcessAction(state, action, { game });\r\n            }\r\n            case PATCH: {\r\n                const oldState = state;\r\n                const newState = JSON.parse(JSON.stringify(oldState));\r\n                const patchError = applyPatch(newState, action.patch);\r\n                const hasError = patchError.some((entry) => entry !== null);\r\n                if (hasError) {\r\n                    error(`Patch ${JSON.stringify(action.patch)} apply failed`);\r\n                    return WithError(oldState, UpdateErrorType.PatchFailed, patchError);\r\n                }\r\n                else {\r\n                    return newState;\r\n                }\r\n            }\r\n            default: {\r\n                return state;\r\n            }\r\n        }\r\n    };\r\n}\n\nexport { CreateGameReducer as C, IsLongFormMove as I, ProcessGameConfig as P, TransientHandlingMiddleware as T };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}