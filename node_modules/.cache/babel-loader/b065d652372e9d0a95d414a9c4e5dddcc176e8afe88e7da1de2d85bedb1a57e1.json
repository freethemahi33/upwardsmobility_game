{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Pointer = void 0;\n/**\nUnescape token part of a JSON Pointer string\n\n`token` should *not* contain any '/' characters.\n\n> Evaluation of each reference token begins by decoding any escaped\n> character sequence.  This is performed by first transforming any\n> occurrence of the sequence '~1' to '/', and then transforming any\n> occurrence of the sequence '~0' to '~'.  By performing the\n> substitutions in this order, an implementation avoids the error of\n> turning '~01' first into '~1' and then into '/', which would be\n> incorrect (the string '~01' correctly becomes '~1' after\n> transformation).\n\nHere's my take:\n\n~1 is unescaped with higher priority than ~0 because it is a lower-order escape character.\nI say \"lower order\" because '/' needs escaping due to the JSON Pointer serialization technique.\nWhereas, '~' is escaped because escaping '/' uses the '~' character.\n*/\nfunction unescape(token) {\n  return token.replace(/~1/g, '/').replace(/~0/g, '~');\n}\n/** Escape token part of a JSON Pointer string\n\n> '~' needs to be encoded as '~0' and '/'\n> needs to be encoded as '~1' when these characters appear in a\n> reference token.\n\nThis is the exact inverse of `unescape()`, so the reverse replacements must take place in reverse order.\n*/\nfunction escape(token) {\n  return token.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n/**\nJSON Pointer representation\n*/\nvar Pointer = /** @class */function () {\n  function Pointer(tokens) {\n    if (tokens === void 0) {\n      tokens = [''];\n    }\n    this.tokens = tokens;\n  }\n  /**\n  `path` *must* be a properly escaped string.\n  */\n  Pointer.fromJSON = function (path) {\n    var tokens = path.split('/').map(unescape);\n    if (tokens[0] !== '') throw new Error(\"Invalid JSON Pointer: \" + path);\n    return new Pointer(tokens);\n  };\n  Pointer.prototype.toString = function () {\n    return this.tokens.map(escape).join('/');\n  };\n  /**\n  Returns an object with 'parent', 'key', and 'value' properties.\n  In the special case that this Pointer's path == \"\",\n  this object will be {parent: null, key: '', value: object}.\n  Otherwise, parent and key will have the property such that parent[key] == value.\n  */\n  Pointer.prototype.evaluate = function (object) {\n    var parent = null;\n    var key = '';\n    var value = object;\n    for (var i = 1, l = this.tokens.length; i < l; i++) {\n      parent = value;\n      key = this.tokens[i];\n      if (key == '__proto__' || key == 'constructor' || key == 'prototype') {\n        continue;\n      }\n      // not sure if this the best way to handle non-existant paths...\n      value = (parent || {})[key];\n    }\n    return {\n      parent: parent,\n      key: key,\n      value: value\n    };\n  };\n  Pointer.prototype.get = function (object) {\n    return this.evaluate(object).value;\n  };\n  Pointer.prototype.set = function (object, value) {\n    var cursor = object;\n    for (var i = 1, l = this.tokens.length - 1, token = this.tokens[i]; i < l; i++) {\n      // not sure if this the best way to handle non-existant paths...\n      cursor = (cursor || {})[token];\n    }\n    if (cursor) {\n      cursor[this.tokens[this.tokens.length - 1]] = value;\n    }\n  };\n  Pointer.prototype.push = function (token) {\n    // mutable\n    this.tokens.push(token);\n  };\n  /**\n  `token` should be a String. It'll be coerced to one anyway.\n     immutable (shallowly)\n  */\n  Pointer.prototype.add = function (token) {\n    var tokens = this.tokens.concat(String(token));\n    return new Pointer(tokens);\n  };\n  return Pointer;\n}();\nexports.Pointer = Pointer;","map":{"version":3,"names":["Object","defineProperty","exports","value","Pointer","unescape","token","replace","escape","tokens","fromJSON","path","split","map","Error","prototype","toString","join","evaluate","object","parent","key","i","l","length","get","set","cursor","push","add","concat","String"],"sources":["/Users/aaron/Desktop/School/488_CMPSC/GUI-based-Web-Game-with-Cloud-Native-Infrastructure-Backend/upwardmobility/node_modules/rfc6902/pointer.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Pointer = void 0;\n/**\nUnescape token part of a JSON Pointer string\n\n`token` should *not* contain any '/' characters.\n\n> Evaluation of each reference token begins by decoding any escaped\n> character sequence.  This is performed by first transforming any\n> occurrence of the sequence '~1' to '/', and then transforming any\n> occurrence of the sequence '~0' to '~'.  By performing the\n> substitutions in this order, an implementation avoids the error of\n> turning '~01' first into '~1' and then into '/', which would be\n> incorrect (the string '~01' correctly becomes '~1' after\n> transformation).\n\nHere's my take:\n\n~1 is unescaped with higher priority than ~0 because it is a lower-order escape character.\nI say \"lower order\" because '/' needs escaping due to the JSON Pointer serialization technique.\nWhereas, '~' is escaped because escaping '/' uses the '~' character.\n*/\nfunction unescape(token) {\n    return token.replace(/~1/g, '/').replace(/~0/g, '~');\n}\n/** Escape token part of a JSON Pointer string\n\n> '~' needs to be encoded as '~0' and '/'\n> needs to be encoded as '~1' when these characters appear in a\n> reference token.\n\nThis is the exact inverse of `unescape()`, so the reverse replacements must take place in reverse order.\n*/\nfunction escape(token) {\n    return token.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n/**\nJSON Pointer representation\n*/\nvar Pointer = /** @class */ (function () {\n    function Pointer(tokens) {\n        if (tokens === void 0) { tokens = ['']; }\n        this.tokens = tokens;\n    }\n    /**\n    `path` *must* be a properly escaped string.\n    */\n    Pointer.fromJSON = function (path) {\n        var tokens = path.split('/').map(unescape);\n        if (tokens[0] !== '')\n            throw new Error(\"Invalid JSON Pointer: \" + path);\n        return new Pointer(tokens);\n    };\n    Pointer.prototype.toString = function () {\n        return this.tokens.map(escape).join('/');\n    };\n    /**\n    Returns an object with 'parent', 'key', and 'value' properties.\n    In the special case that this Pointer's path == \"\",\n    this object will be {parent: null, key: '', value: object}.\n    Otherwise, parent and key will have the property such that parent[key] == value.\n    */\n    Pointer.prototype.evaluate = function (object) {\n        var parent = null;\n        var key = '';\n        var value = object;\n        for (var i = 1, l = this.tokens.length; i < l; i++) {\n            parent = value;\n            key = this.tokens[i];\n            if (key == '__proto__' || key == 'constructor' || key == 'prototype') {\n                continue;\n            }\n            // not sure if this the best way to handle non-existant paths...\n            value = (parent || {})[key];\n        }\n        return { parent: parent, key: key, value: value };\n    };\n    Pointer.prototype.get = function (object) {\n        return this.evaluate(object).value;\n    };\n    Pointer.prototype.set = function (object, value) {\n        var cursor = object;\n        for (var i = 1, l = this.tokens.length - 1, token = this.tokens[i]; i < l; i++) {\n            // not sure if this the best way to handle non-existant paths...\n            cursor = (cursor || {})[token];\n        }\n        if (cursor) {\n            cursor[this.tokens[this.tokens.length - 1]] = value;\n        }\n    };\n    Pointer.prototype.push = function (token) {\n        // mutable\n        this.tokens.push(token);\n    };\n    /**\n    `token` should be a String. It'll be coerced to one anyway.\n  \n    immutable (shallowly)\n    */\n    Pointer.prototype.add = function (token) {\n        var tokens = this.tokens.concat(String(token));\n        return new Pointer(tokens);\n    };\n    return Pointer;\n}());\nexports.Pointer = Pointer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}