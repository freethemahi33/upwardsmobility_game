{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clone = exports.objectType = exports.hasOwnProperty = void 0;\nexports.hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction objectType(object) {\n  if (object === undefined) {\n    return 'undefined';\n  }\n  if (object === null) {\n    return 'null';\n  }\n  if (Array.isArray(object)) {\n    return 'array';\n  }\n  return typeof object;\n}\nexports.objectType = objectType;\nfunction isNonPrimitive(value) {\n  // loose-equality checking for null is faster than strict checking for each of null/undefined/true/false\n  // checking null first, then calling typeof, is faster than vice-versa\n  return value != null && typeof value == 'object';\n}\n/**\nRecursively copy a value.\n\n@param source - should be a JavaScript primitive, Array, Date, or (plain old) Object.\n@returns copy of source where every Array and Object have been recursively\n         reconstructed from their constituent elements\n*/\nfunction clone(source) {\n  if (!isNonPrimitive(source)) {\n    // short-circuiting is faster than a single return\n    return source;\n  }\n  // x.constructor == Array is the fastest way to check if x is an Array\n  if (source.constructor == Array) {\n    // construction via imperative for-loop is faster than source.map(arrayVsObject)\n    var length_1 = source.length;\n    // setting the Array length during construction is faster than just `[]` or `new Array()`\n    var arrayTarget = new Array(length_1);\n    for (var i = 0; i < length_1; i++) {\n      arrayTarget[i] = clone(source[i]);\n    }\n    return arrayTarget;\n  }\n  // Date\n  if (source.constructor == Date) {\n    var dateTarget = new Date(+source);\n    return dateTarget;\n  }\n  // Object\n  var objectTarget = {};\n  // declaring the variable (with const) inside the loop is faster\n  for (var key in source) {\n    // hasOwnProperty costs a bit of performance, but it's semantically necessary\n    // using a global helper is MUCH faster than calling source.hasOwnProperty(key)\n    if (exports.hasOwnProperty.call(source, key)) {\n      objectTarget[key] = clone(source[key]);\n    }\n  }\n  return objectTarget;\n}\nexports.clone = clone;","map":{"version":3,"names":["Object","defineProperty","exports","value","clone","objectType","hasOwnProperty","prototype","object","undefined","Array","isArray","isNonPrimitive","source","constructor","length_1","length","arrayTarget","i","Date","dateTarget","objectTarget","key","call"],"sources":["/Users/aaron/Desktop/School/488_CMPSC/GUI-based-Web-Game-with-Cloud-Native-Infrastructure-Backend/upwardmobility/node_modules/rfc6902/util.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.clone = exports.objectType = exports.hasOwnProperty = void 0;\nexports.hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction objectType(object) {\n    if (object === undefined) {\n        return 'undefined';\n    }\n    if (object === null) {\n        return 'null';\n    }\n    if (Array.isArray(object)) {\n        return 'array';\n    }\n    return typeof object;\n}\nexports.objectType = objectType;\nfunction isNonPrimitive(value) {\n    // loose-equality checking for null is faster than strict checking for each of null/undefined/true/false\n    // checking null first, then calling typeof, is faster than vice-versa\n    return value != null && typeof value == 'object';\n}\n/**\nRecursively copy a value.\n\n@param source - should be a JavaScript primitive, Array, Date, or (plain old) Object.\n@returns copy of source where every Array and Object have been recursively\n         reconstructed from their constituent elements\n*/\nfunction clone(source) {\n    if (!isNonPrimitive(source)) {\n        // short-circuiting is faster than a single return\n        return source;\n    }\n    // x.constructor == Array is the fastest way to check if x is an Array\n    if (source.constructor == Array) {\n        // construction via imperative for-loop is faster than source.map(arrayVsObject)\n        var length_1 = source.length;\n        // setting the Array length during construction is faster than just `[]` or `new Array()`\n        var arrayTarget = new Array(length_1);\n        for (var i = 0; i < length_1; i++) {\n            arrayTarget[i] = clone(source[i]);\n        }\n        return arrayTarget;\n    }\n    // Date\n    if (source.constructor == Date) {\n        var dateTarget = new Date(+source);\n        return dateTarget;\n    }\n    // Object\n    var objectTarget = {};\n    // declaring the variable (with const) inside the loop is faster\n    for (var key in source) {\n        // hasOwnProperty costs a bit of performance, but it's semantically necessary\n        // using a global helper is MUCH faster than calling source.hasOwnProperty(key)\n        if (exports.hasOwnProperty.call(source, key)) {\n            objectTarget[key] = clone(source[key]);\n        }\n    }\n    return objectTarget;\n}\nexports.clone = clone;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,KAAK,GAAGF,OAAO,CAACG,UAAU,GAAGH,OAAO,CAACI,cAAc,GAAG,KAAK,CAAC;AACpEJ,OAAO,CAACI,cAAc,GAAGN,MAAM,CAACO,SAAS,CAACD,cAAc;AACxD,SAASD,UAAUA,CAACG,MAAM,EAAE;EACxB,IAAIA,MAAM,KAAKC,SAAS,EAAE;IACtB,OAAO,WAAW;EACtB;EACA,IAAID,MAAM,KAAK,IAAI,EAAE;IACjB,OAAO,MAAM;EACjB;EACA,IAAIE,KAAK,CAACC,OAAO,CAACH,MAAM,CAAC,EAAE;IACvB,OAAO,OAAO;EAClB;EACA,OAAO,OAAOA,MAAM;AACxB;AACAN,OAAO,CAACG,UAAU,GAAGA,UAAU;AAC/B,SAASO,cAAcA,CAACT,KAAK,EAAE;EAC3B;EACA;EACA,OAAOA,KAAK,IAAI,IAAI,IAAI,OAAOA,KAAK,IAAI,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,KAAKA,CAACS,MAAM,EAAE;EACnB,IAAI,CAACD,cAAc,CAACC,MAAM,CAAC,EAAE;IACzB;IACA,OAAOA,MAAM;EACjB;EACA;EACA,IAAIA,MAAM,CAACC,WAAW,IAAIJ,KAAK,EAAE;IAC7B;IACA,IAAIK,QAAQ,GAAGF,MAAM,CAACG,MAAM;IAC5B;IACA,IAAIC,WAAW,GAAG,IAAIP,KAAK,CAACK,QAAQ,CAAC;IACrC,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,QAAQ,EAAEG,CAAC,EAAE,EAAE;MAC/BD,WAAW,CAACC,CAAC,CAAC,GAAGd,KAAK,CAACS,MAAM,CAACK,CAAC,CAAC,CAAC;IACrC;IACA,OAAOD,WAAW;EACtB;EACA;EACA,IAAIJ,MAAM,CAACC,WAAW,IAAIK,IAAI,EAAE;IAC5B,IAAIC,UAAU,GAAG,IAAID,IAAI,CAAC,CAACN,MAAM,CAAC;IAClC,OAAOO,UAAU;EACrB;EACA;EACA,IAAIC,YAAY,GAAG,CAAC,CAAC;EACrB;EACA,KAAK,IAAIC,GAAG,IAAIT,MAAM,EAAE;IACpB;IACA;IACA,IAAIX,OAAO,CAACI,cAAc,CAACiB,IAAI,CAACV,MAAM,EAAES,GAAG,CAAC,EAAE;MAC1CD,YAAY,CAACC,GAAG,CAAC,GAAGlB,KAAK,CAACS,MAAM,CAACS,GAAG,CAAC,CAAC;IAC1C;EACJ;EACA,OAAOD,YAAY;AACvB;AACAnB,OAAO,CAACE,KAAK,GAAGA,KAAK"},"metadata":{},"sourceType":"script","externalDependencies":[]}