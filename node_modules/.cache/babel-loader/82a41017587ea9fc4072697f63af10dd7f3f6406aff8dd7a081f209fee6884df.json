{"ast":null,"code":"import { nanoid } from 'nanoid/non-secure';\nimport { D as Debug } from './Debug-8242c26e.js';\nimport { applyMiddleware, compose, createStore } from 'redux';\nimport { u as reset, v as undo, w as redo, s as sync, x as PlayerView, A as ActionCreators, k as SYNC, l as UPDATE, P as PATCH, m as RESET, R as REDO, j as UNDO, o as GAME_EVENT, M as MAKE_MOVE, p as STRIP_TRANSIENTS, y as patch, z as update } from './turn-order-8cc4909b.js';\nimport { P as ProcessGameConfig, C as CreateGameReducer, T as TransientHandlingMiddleware } from './reducer-24ea3e4c.js';\nimport { I as InitializeGame } from './initialize-7316768f.js';\nimport { T as Transport } from './transport-ce07b771.js';\n\n/**\r\n * This class doesn’t do anything, but simplifies the client class by providing\r\n * dummy functions to call, so we don’t need to mock them in the client.\r\n */\nclass DummyImpl extends Transport {\n  connect() {}\n  disconnect() {}\n  sendAction() {}\n  sendChatMessage() {}\n  requestSync() {}\n  updateCredentials() {}\n  updateMatchID() {}\n  updatePlayerID() {}\n}\nconst DummyTransport = opts => new DummyImpl(opts);\n\n/**\r\n * Class to manage boardgame.io clients and limit debug panel rendering.\r\n */\nclass ClientManager {\n  constructor() {\n    this.debugPanel = null;\n    this.currentClient = null;\n    this.clients = new Map();\n    this.subscribers = new Map();\n  }\n  /**\r\n   * Register a client with the client manager.\r\n   */\n  register(client) {\n    // Add client to clients map.\n    this.clients.set(client, client);\n    // Mount debug for this client (no-op if another debug is already mounted).\n    this.mountDebug(client);\n    this.notifySubscribers();\n  }\n  /**\r\n   * Unregister a client from the client manager.\r\n   */\n  unregister(client) {\n    // Remove client from clients map.\n    this.clients.delete(client);\n    if (this.currentClient === client) {\n      // If the removed client owned the debug panel, unmount it.\n      this.unmountDebug();\n      // Mount debug panel for next available client.\n      for (const [client] of this.clients) {\n        if (this.debugPanel) break;\n        this.mountDebug(client);\n      }\n    }\n    this.notifySubscribers();\n  }\n  /**\r\n   * Subscribe to the client manager state.\r\n   * Calls the passed callback each time the current client changes or a client\r\n   * registers/unregisters.\r\n   * Returns a function to unsubscribe from the state updates.\r\n   */\n  subscribe(callback) {\n    const id = Symbol();\n    this.subscribers.set(id, callback);\n    callback(this.getState());\n    return () => {\n      this.subscribers.delete(id);\n    };\n  }\n  /**\r\n   * Switch to a client with a matching playerID.\r\n   */\n  switchPlayerID(playerID) {\n    // For multiplayer clients, try switching control to a different client\n    // that is using the same transport layer.\n    if (this.currentClient.multiplayer) {\n      for (const [client] of this.clients) {\n        if (client.playerID === playerID && client.debugOpt !== false && client.multiplayer === this.currentClient.multiplayer) {\n          this.switchToClient(client);\n          return;\n        }\n      }\n    }\n    // If no client matches, update the playerID for the current client.\n    this.currentClient.updatePlayerID(playerID);\n    this.notifySubscribers();\n  }\n  /**\r\n   * Set the passed client as the active client for debugging.\r\n   */\n  switchToClient(client) {\n    if (client === this.currentClient) return;\n    this.unmountDebug();\n    this.mountDebug(client);\n    this.notifySubscribers();\n  }\n  /**\r\n   * Notify all subscribers of changes to the client manager state.\r\n   */\n  notifySubscribers() {\n    const arg = this.getState();\n    this.subscribers.forEach(cb => {\n      cb(arg);\n    });\n  }\n  /**\r\n   * Get the client manager state.\r\n   */\n  getState() {\n    return {\n      client: this.currentClient,\n      debuggableClients: this.getDebuggableClients()\n    };\n  }\n  /**\r\n   * Get an array of the registered clients that haven’t disabled the debug panel.\r\n   */\n  getDebuggableClients() {\n    return [...this.clients.values()].filter(client => client.debugOpt !== false);\n  }\n  /**\r\n   * Mount the debug panel using the passed client.\r\n   */\n  mountDebug(client) {\n    if (client.debugOpt === false || this.debugPanel !== null || typeof document === 'undefined') {\n      return;\n    }\n    let DebugImpl;\n    let target = document.body;\n    if (process.env.NODE_ENV !== 'production') {\n      DebugImpl = Debug;\n    }\n    if (client.debugOpt && client.debugOpt !== true) {\n      DebugImpl = client.debugOpt.impl || DebugImpl;\n      target = client.debugOpt.target || target;\n    }\n    if (DebugImpl) {\n      this.currentClient = client;\n      this.debugPanel = new DebugImpl({\n        target,\n        props: {\n          clientManager: this\n        }\n      });\n    }\n  }\n  /**\r\n   * Unmount the debug panel.\r\n   */\n  unmountDebug() {\n    this.debugPanel.$destroy();\n    this.debugPanel = null;\n    this.currentClient = null;\n  }\n}\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n/**\r\n * Global client manager instance that all clients register with.\r\n */\nconst GlobalClientManager = new ClientManager();\n/**\r\n * Standardise the passed playerID, using currentPlayer if appropriate.\r\n */\nfunction assumedPlayerID(playerID, store, multiplayer) {\n  // In singleplayer mode, if the client does not have a playerID\n  // associated with it, we attach the currentPlayer as playerID.\n  if (!multiplayer && (playerID === null || playerID === undefined)) {\n    const state = store.getState();\n    playerID = state.ctx.currentPlayer;\n  }\n  return playerID;\n}\n/**\r\n * createDispatchers\r\n *\r\n * Create action dispatcher wrappers with bound playerID and credentials\r\n */\nfunction createDispatchers(storeActionType, innerActionNames, store, playerID, credentials, multiplayer) {\n  const dispatchers = {};\n  for (const name of innerActionNames) {\n    dispatchers[name] = function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      const action = ActionCreators[storeActionType](name, args, assumedPlayerID(playerID, store, multiplayer), credentials);\n      store.dispatch(action);\n    };\n  }\n  return dispatchers;\n}\n// Creates a set of dispatchers to make moves.\nconst createMoveDispatchers = createDispatchers.bind(null, 'makeMove');\n// Creates a set of dispatchers to dispatch game flow events.\nconst createEventDispatchers = createDispatchers.bind(null, 'gameEvent');\n// Creates a set of dispatchers to dispatch actions to plugins.\nconst createPluginDispatchers = createDispatchers.bind(null, 'plugin');\n/**\r\n * Implementation of Client (see below).\r\n */\nclass _ClientImpl {\n  constructor(_ref) {\n    let {\n      game,\n      debug,\n      numPlayers,\n      multiplayer,\n      matchID: matchID,\n      playerID,\n      credentials,\n      enhancer\n    } = _ref;\n    this.game = ProcessGameConfig(game);\n    this.playerID = playerID;\n    this.matchID = matchID || 'default';\n    this.credentials = credentials;\n    this.multiplayer = multiplayer;\n    this.debugOpt = debug;\n    this.manager = GlobalClientManager;\n    this.gameStateOverride = null;\n    this.subscribers = {};\n    this._running = false;\n    this.reducer = CreateGameReducer({\n      game: this.game,\n      isClient: multiplayer !== undefined\n    });\n    this.initialState = null;\n    if (!multiplayer) {\n      this.initialState = InitializeGame({\n        game: this.game,\n        numPlayers\n      });\n    }\n    this.reset = () => {\n      this.store.dispatch(reset(this.initialState));\n    };\n    this.undo = () => {\n      const undo$1 = undo(assumedPlayerID(this.playerID, this.store, this.multiplayer), this.credentials);\n      this.store.dispatch(undo$1);\n    };\n    this.redo = () => {\n      const redo$1 = redo(assumedPlayerID(this.playerID, this.store, this.multiplayer), this.credentials);\n      this.store.dispatch(redo$1);\n    };\n    this.log = [];\n    /**\r\n     * Middleware that manages the log object.\r\n     * Reducers generate deltalogs, which are log events\r\n     * that are the result of application of a single action.\r\n     * The master may also send back a deltalog or the entire\r\n     * log depending on the type of request.\r\n     * The middleware below takes care of all these cases while\r\n     * managing the log object.\r\n     */\n    const LogMiddleware = store => next => action => {\n      const result = next(action);\n      const state = store.getState();\n      switch (action.type) {\n        case MAKE_MOVE:\n        case GAME_EVENT:\n        case UNDO:\n        case REDO:\n          {\n            const deltalog = state.deltalog;\n            this.log = [...this.log, ...deltalog];\n            break;\n          }\n        case RESET:\n          {\n            this.log = [];\n            break;\n          }\n        case PATCH:\n        case UPDATE:\n          {\n            let id = -1;\n            if (this.log.length > 0) {\n              id = this.log[this.log.length - 1]._stateID;\n            }\n            let deltalog = action.deltalog || [];\n            // Filter out actions that are already present\n            // in the current log. This may occur when the\n            // client adds an entry to the log followed by\n            // the update from the master here.\n            deltalog = deltalog.filter(l => l._stateID > id);\n            this.log = [...this.log, ...deltalog];\n            break;\n          }\n        case SYNC:\n          {\n            this.initialState = action.initialState;\n            this.log = action.log || [];\n            break;\n          }\n      }\n      return result;\n    };\n    /**\r\n     * Middleware that intercepts actions and sends them to the master,\r\n     * which keeps the authoritative version of the state.\r\n     */\n    const TransportMiddleware = store => next => action => {\n      const baseState = store.getState();\n      const result = next(action);\n      if (!('clientOnly' in action) && action.type !== STRIP_TRANSIENTS) {\n        this.transport.sendAction(baseState, action);\n      }\n      return result;\n    };\n    /**\r\n     * Middleware that intercepts actions and invokes the subscription callback.\r\n     */\n    const SubscriptionMiddleware = () => next => action => {\n      const result = next(action);\n      this.notifySubscribers();\n      return result;\n    };\n    const middleware = applyMiddleware(TransientHandlingMiddleware, SubscriptionMiddleware, TransportMiddleware, LogMiddleware);\n    enhancer = enhancer !== undefined ? compose(middleware, enhancer) : middleware;\n    this.store = createStore(this.reducer, this.initialState, enhancer);\n    if (!multiplayer) multiplayer = DummyTransport;\n    this.transport = multiplayer({\n      transportDataCallback: data => this.receiveTransportData(data),\n      gameKey: game,\n      game: this.game,\n      matchID,\n      playerID,\n      credentials,\n      gameName: this.game.name,\n      numPlayers\n    });\n    this.createDispatchers();\n    this.chatMessages = [];\n    this.sendChatMessage = payload => {\n      this.transport.sendChatMessage(this.matchID, {\n        id: nanoid(7),\n        sender: this.playerID,\n        payload: payload\n      });\n    };\n  }\n  /** Handle incoming match data from a multiplayer transport. */\n  receiveMatchData(matchData) {\n    this.matchData = matchData;\n    this.notifySubscribers();\n  }\n  /** Handle an incoming chat message from a multiplayer transport. */\n  receiveChatMessage(message) {\n    this.chatMessages = [...this.chatMessages, message];\n    this.notifySubscribers();\n  }\n  /** Handle all incoming updates from a multiplayer transport. */\n  receiveTransportData(data) {\n    const [matchID] = data.args;\n    if (matchID !== this.matchID) return;\n    switch (data.type) {\n      case 'sync':\n        {\n          const [, syncInfo] = data.args;\n          const action = sync(syncInfo);\n          this.receiveMatchData(syncInfo.filteredMetadata);\n          this.store.dispatch(action);\n          break;\n        }\n      case 'update':\n        {\n          const [, state, deltalog] = data.args;\n          const currentState = this.store.getState();\n          if (state._stateID >= currentState._stateID) {\n            const action = update(state, deltalog);\n            this.store.dispatch(action);\n          }\n          break;\n        }\n      case 'patch':\n        {\n          const [, prevStateID, stateID, patch$1, deltalog] = data.args;\n          const currentStateID = this.store.getState()._stateID;\n          if (prevStateID !== currentStateID) break;\n          const action = patch(prevStateID, stateID, patch$1, deltalog);\n          this.store.dispatch(action);\n          // Emit sync if patch apply failed.\n          if (this.store.getState()._stateID === currentStateID) {\n            this.transport.requestSync();\n          }\n          break;\n        }\n      case 'matchData':\n        {\n          const [, matchData] = data.args;\n          this.receiveMatchData(matchData);\n          break;\n        }\n      case 'chat':\n        {\n          const [, chatMessage] = data.args;\n          this.receiveChatMessage(chatMessage);\n          break;\n        }\n    }\n  }\n  notifySubscribers() {\n    Object.values(this.subscribers).forEach(fn => fn(this.getState()));\n  }\n  overrideGameState(state) {\n    this.gameStateOverride = state;\n    this.notifySubscribers();\n  }\n  start() {\n    this.transport.connect();\n    this._running = true;\n    this.manager.register(this);\n  }\n  stop() {\n    this.transport.disconnect();\n    this._running = false;\n    this.manager.unregister(this);\n  }\n  subscribe(fn) {\n    const id = Object.keys(this.subscribers).length;\n    this.subscribers[id] = fn;\n    this.transport.subscribeToConnectionStatus(() => this.notifySubscribers());\n    if (this._running || !this.multiplayer) {\n      fn(this.getState());\n    }\n    // Return a handle that allows the caller to unsubscribe.\n    return () => {\n      delete this.subscribers[id];\n    };\n  }\n  getInitialState() {\n    return this.initialState;\n  }\n  getState() {\n    let state = this.store.getState();\n    if (this.gameStateOverride !== null) {\n      state = this.gameStateOverride;\n    }\n    // This is the state before a sync with the game master.\n    if (state === null) {\n      return state;\n    }\n    // isActive.\n    let isActive = true;\n    const isPlayerActive = this.game.flow.isPlayerActive(state.G, state.ctx, this.playerID);\n    if (this.multiplayer && !isPlayerActive) {\n      isActive = false;\n    }\n    if (!this.multiplayer && this.playerID !== null && this.playerID !== undefined && !isPlayerActive) {\n      isActive = false;\n    }\n    if (state.ctx.gameover !== undefined) {\n      isActive = false;\n    }\n    // Secrets are normally stripped on the server,\n    // but we also strip them here so that game developers\n    // can see their effects while prototyping.\n    // Do not strip again if this is a multiplayer game\n    // since the server has already stripped secret info. (issue #818)\n    if (!this.multiplayer) {\n      state = {\n        ...state,\n        G: this.game.playerView({\n          G: state.G,\n          ctx: state.ctx,\n          playerID: this.playerID\n        }),\n        plugins: PlayerView(state, this)\n      };\n    }\n    // Combine into return value.\n    return {\n      ...state,\n      log: this.log,\n      isActive,\n      isConnected: this.transport.isConnected\n    };\n  }\n  createDispatchers() {\n    this.moves = createMoveDispatchers(this.game.moveNames, this.store, this.playerID, this.credentials, this.multiplayer);\n    this.events = createEventDispatchers(this.game.flow.enabledEventNames, this.store, this.playerID, this.credentials, this.multiplayer);\n    this.plugins = createPluginDispatchers(this.game.pluginNames, this.store, this.playerID, this.credentials, this.multiplayer);\n  }\n  updatePlayerID(playerID) {\n    this.playerID = playerID;\n    this.createDispatchers();\n    this.transport.updatePlayerID(playerID);\n    this.notifySubscribers();\n  }\n  updateMatchID(matchID) {\n    this.matchID = matchID;\n    this.createDispatchers();\n    this.transport.updateMatchID(matchID);\n    this.notifySubscribers();\n  }\n  updateCredentials(credentials) {\n    this.credentials = credentials;\n    this.createDispatchers();\n    this.transport.updateCredentials(credentials);\n    this.notifySubscribers();\n  }\n}\n/**\r\n * Client\r\n *\r\n * boardgame.io JS client.\r\n *\r\n * @param {...object} game - The return value of `Game`.\r\n * @param {...object} numPlayers - The number of players.\r\n * @param {...object} multiplayer - Set to a falsy value or a transportFactory, e.g., SocketIO()\r\n * @param {...object} matchID - The matchID that you want to connect to.\r\n * @param {...object} playerID - The playerID associated with this client.\r\n * @param {...string} credentials - The authentication credentials associated with this client.\r\n *\r\n * Returns:\r\n *   A JS object that provides an API to interact with the\r\n *   game by dispatching moves and events.\r\n */\nfunction Client(opts) {\n  return new _ClientImpl(opts);\n}\nexport { Client as C };","map":{"version":3,"names":["nanoid","D","Debug","applyMiddleware","compose","createStore","u","reset","v","undo","w","redo","s","sync","x","PlayerView","A","ActionCreators","k","SYNC","l","UPDATE","P","PATCH","m","RESET","R","REDO","j","UNDO","o","GAME_EVENT","M","MAKE_MOVE","p","STRIP_TRANSIENTS","y","patch","z","update","ProcessGameConfig","C","CreateGameReducer","T","TransientHandlingMiddleware","I","InitializeGame","Transport","DummyImpl","connect","disconnect","sendAction","sendChatMessage","requestSync","updateCredentials","updateMatchID","updatePlayerID","DummyTransport","opts","ClientManager","constructor","debugPanel","currentClient","clients","Map","subscribers","register","client","set","mountDebug","notifySubscribers","unregister","delete","unmountDebug","subscribe","callback","id","Symbol","getState","switchPlayerID","playerID","multiplayer","debugOpt","switchToClient","arg","forEach","cb","debuggableClients","getDebuggableClients","values","filter","document","DebugImpl","target","body","process","env","NODE_ENV","impl","props","clientManager","$destroy","GlobalClientManager","assumedPlayerID","store","undefined","state","ctx","currentPlayer","createDispatchers","storeActionType","innerActionNames","credentials","dispatchers","name","_len","arguments","length","args","Array","_key","action","dispatch","createMoveDispatchers","bind","createEventDispatchers","createPluginDispatchers","_ClientImpl","_ref","game","debug","numPlayers","matchID","enhancer","manager","gameStateOverride","_running","reducer","isClient","initialState","undo$1","redo$1","log","LogMiddleware","next","result","type","deltalog","_stateID","TransportMiddleware","baseState","transport","SubscriptionMiddleware","middleware","transportDataCallback","data","receiveTransportData","gameKey","gameName","chatMessages","payload","sender","receiveMatchData","matchData","receiveChatMessage","message","syncInfo","filteredMetadata","currentState","prevStateID","stateID","patch$1","currentStateID","chatMessage","Object","fn","overrideGameState","start","stop","keys","subscribeToConnectionStatus","getInitialState","isActive","isPlayerActive","flow","G","gameover","playerView","plugins","isConnected","moves","moveNames","events","enabledEventNames","pluginNames","Client"],"sources":["/Users/aaron/Desktop/School/488_CMPSC/GUI-based-Web-Game-with-Cloud-Native-Infrastructure-Backend 3-21 copy 2/upwardmobility/node_modules/boardgame.io/dist/esm/client-f7f02b82.js"],"sourcesContent":["import { nanoid } from 'nanoid/non-secure';\nimport { D as Debug } from './Debug-8242c26e.js';\nimport { applyMiddleware, compose, createStore } from 'redux';\nimport { u as reset, v as undo, w as redo, s as sync, x as PlayerView, A as ActionCreators, k as SYNC, l as UPDATE, P as PATCH, m as RESET, R as REDO, j as UNDO, o as GAME_EVENT, M as MAKE_MOVE, p as STRIP_TRANSIENTS, y as patch, z as update } from './turn-order-8cc4909b.js';\nimport { P as ProcessGameConfig, C as CreateGameReducer, T as TransientHandlingMiddleware } from './reducer-24ea3e4c.js';\nimport { I as InitializeGame } from './initialize-7316768f.js';\nimport { T as Transport } from './transport-ce07b771.js';\n\n/**\r\n * This class doesn’t do anything, but simplifies the client class by providing\r\n * dummy functions to call, so we don’t need to mock them in the client.\r\n */\r\nclass DummyImpl extends Transport {\r\n    connect() { }\r\n    disconnect() { }\r\n    sendAction() { }\r\n    sendChatMessage() { }\r\n    requestSync() { }\r\n    updateCredentials() { }\r\n    updateMatchID() { }\r\n    updatePlayerID() { }\r\n}\r\nconst DummyTransport = (opts) => new DummyImpl(opts);\n\n/**\r\n * Class to manage boardgame.io clients and limit debug panel rendering.\r\n */\r\nclass ClientManager {\r\n    constructor() {\r\n        this.debugPanel = null;\r\n        this.currentClient = null;\r\n        this.clients = new Map();\r\n        this.subscribers = new Map();\r\n    }\r\n    /**\r\n     * Register a client with the client manager.\r\n     */\r\n    register(client) {\r\n        // Add client to clients map.\r\n        this.clients.set(client, client);\r\n        // Mount debug for this client (no-op if another debug is already mounted).\r\n        this.mountDebug(client);\r\n        this.notifySubscribers();\r\n    }\r\n    /**\r\n     * Unregister a client from the client manager.\r\n     */\r\n    unregister(client) {\r\n        // Remove client from clients map.\r\n        this.clients.delete(client);\r\n        if (this.currentClient === client) {\r\n            // If the removed client owned the debug panel, unmount it.\r\n            this.unmountDebug();\r\n            // Mount debug panel for next available client.\r\n            for (const [client] of this.clients) {\r\n                if (this.debugPanel)\r\n                    break;\r\n                this.mountDebug(client);\r\n            }\r\n        }\r\n        this.notifySubscribers();\r\n    }\r\n    /**\r\n     * Subscribe to the client manager state.\r\n     * Calls the passed callback each time the current client changes or a client\r\n     * registers/unregisters.\r\n     * Returns a function to unsubscribe from the state updates.\r\n     */\r\n    subscribe(callback) {\r\n        const id = Symbol();\r\n        this.subscribers.set(id, callback);\r\n        callback(this.getState());\r\n        return () => {\r\n            this.subscribers.delete(id);\r\n        };\r\n    }\r\n    /**\r\n     * Switch to a client with a matching playerID.\r\n     */\r\n    switchPlayerID(playerID) {\r\n        // For multiplayer clients, try switching control to a different client\r\n        // that is using the same transport layer.\r\n        if (this.currentClient.multiplayer) {\r\n            for (const [client] of this.clients) {\r\n                if (client.playerID === playerID &&\r\n                    client.debugOpt !== false &&\r\n                    client.multiplayer === this.currentClient.multiplayer) {\r\n                    this.switchToClient(client);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        // If no client matches, update the playerID for the current client.\r\n        this.currentClient.updatePlayerID(playerID);\r\n        this.notifySubscribers();\r\n    }\r\n    /**\r\n     * Set the passed client as the active client for debugging.\r\n     */\r\n    switchToClient(client) {\r\n        if (client === this.currentClient)\r\n            return;\r\n        this.unmountDebug();\r\n        this.mountDebug(client);\r\n        this.notifySubscribers();\r\n    }\r\n    /**\r\n     * Notify all subscribers of changes to the client manager state.\r\n     */\r\n    notifySubscribers() {\r\n        const arg = this.getState();\r\n        this.subscribers.forEach((cb) => {\r\n            cb(arg);\r\n        });\r\n    }\r\n    /**\r\n     * Get the client manager state.\r\n     */\r\n    getState() {\r\n        return {\r\n            client: this.currentClient,\r\n            debuggableClients: this.getDebuggableClients(),\r\n        };\r\n    }\r\n    /**\r\n     * Get an array of the registered clients that haven’t disabled the debug panel.\r\n     */\r\n    getDebuggableClients() {\r\n        return [...this.clients.values()].filter((client) => client.debugOpt !== false);\r\n    }\r\n    /**\r\n     * Mount the debug panel using the passed client.\r\n     */\r\n    mountDebug(client) {\r\n        if (client.debugOpt === false ||\r\n            this.debugPanel !== null ||\r\n            typeof document === 'undefined') {\r\n            return;\r\n        }\r\n        let DebugImpl;\r\n        let target = document.body;\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            DebugImpl = Debug;\r\n        }\r\n        if (client.debugOpt && client.debugOpt !== true) {\r\n            DebugImpl = client.debugOpt.impl || DebugImpl;\r\n            target = client.debugOpt.target || target;\r\n        }\r\n        if (DebugImpl) {\r\n            this.currentClient = client;\r\n            this.debugPanel = new DebugImpl({\r\n                target,\r\n                props: { clientManager: this },\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Unmount the debug panel.\r\n     */\r\n    unmountDebug() {\r\n        this.debugPanel.$destroy();\r\n        this.debugPanel = null;\r\n        this.currentClient = null;\r\n    }\r\n}\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Global client manager instance that all clients register with.\r\n */\r\nconst GlobalClientManager = new ClientManager();\r\n/**\r\n * Standardise the passed playerID, using currentPlayer if appropriate.\r\n */\r\nfunction assumedPlayerID(playerID, store, multiplayer) {\r\n    // In singleplayer mode, if the client does not have a playerID\r\n    // associated with it, we attach the currentPlayer as playerID.\r\n    if (!multiplayer && (playerID === null || playerID === undefined)) {\r\n        const state = store.getState();\r\n        playerID = state.ctx.currentPlayer;\r\n    }\r\n    return playerID;\r\n}\r\n/**\r\n * createDispatchers\r\n *\r\n * Create action dispatcher wrappers with bound playerID and credentials\r\n */\r\nfunction createDispatchers(storeActionType, innerActionNames, store, playerID, credentials, multiplayer) {\r\n    const dispatchers = {};\r\n    for (const name of innerActionNames) {\r\n        dispatchers[name] = (...args) => {\r\n            const action = ActionCreators[storeActionType](name, args, assumedPlayerID(playerID, store, multiplayer), credentials);\r\n            store.dispatch(action);\r\n        };\r\n    }\r\n    return dispatchers;\r\n}\r\n// Creates a set of dispatchers to make moves.\r\nconst createMoveDispatchers = createDispatchers.bind(null, 'makeMove');\r\n// Creates a set of dispatchers to dispatch game flow events.\r\nconst createEventDispatchers = createDispatchers.bind(null, 'gameEvent');\r\n// Creates a set of dispatchers to dispatch actions to plugins.\r\nconst createPluginDispatchers = createDispatchers.bind(null, 'plugin');\r\n/**\r\n * Implementation of Client (see below).\r\n */\r\nclass _ClientImpl {\r\n    constructor({ game, debug, numPlayers, multiplayer, matchID: matchID, playerID, credentials, enhancer, }) {\r\n        this.game = ProcessGameConfig(game);\r\n        this.playerID = playerID;\r\n        this.matchID = matchID || 'default';\r\n        this.credentials = credentials;\r\n        this.multiplayer = multiplayer;\r\n        this.debugOpt = debug;\r\n        this.manager = GlobalClientManager;\r\n        this.gameStateOverride = null;\r\n        this.subscribers = {};\r\n        this._running = false;\r\n        this.reducer = CreateGameReducer({\r\n            game: this.game,\r\n            isClient: multiplayer !== undefined,\r\n        });\r\n        this.initialState = null;\r\n        if (!multiplayer) {\r\n            this.initialState = InitializeGame({ game: this.game, numPlayers });\r\n        }\r\n        this.reset = () => {\r\n            this.store.dispatch(reset(this.initialState));\r\n        };\r\n        this.undo = () => {\r\n            const undo$1 = undo(assumedPlayerID(this.playerID, this.store, this.multiplayer), this.credentials);\r\n            this.store.dispatch(undo$1);\r\n        };\r\n        this.redo = () => {\r\n            const redo$1 = redo(assumedPlayerID(this.playerID, this.store, this.multiplayer), this.credentials);\r\n            this.store.dispatch(redo$1);\r\n        };\r\n        this.log = [];\r\n        /**\r\n         * Middleware that manages the log object.\r\n         * Reducers generate deltalogs, which are log events\r\n         * that are the result of application of a single action.\r\n         * The master may also send back a deltalog or the entire\r\n         * log depending on the type of request.\r\n         * The middleware below takes care of all these cases while\r\n         * managing the log object.\r\n         */\r\n        const LogMiddleware = (store) => (next) => (action) => {\r\n            const result = next(action);\r\n            const state = store.getState();\r\n            switch (action.type) {\r\n                case MAKE_MOVE:\r\n                case GAME_EVENT:\r\n                case UNDO:\r\n                case REDO: {\r\n                    const deltalog = state.deltalog;\r\n                    this.log = [...this.log, ...deltalog];\r\n                    break;\r\n                }\r\n                case RESET: {\r\n                    this.log = [];\r\n                    break;\r\n                }\r\n                case PATCH:\r\n                case UPDATE: {\r\n                    let id = -1;\r\n                    if (this.log.length > 0) {\r\n                        id = this.log[this.log.length - 1]._stateID;\r\n                    }\r\n                    let deltalog = action.deltalog || [];\r\n                    // Filter out actions that are already present\r\n                    // in the current log. This may occur when the\r\n                    // client adds an entry to the log followed by\r\n                    // the update from the master here.\r\n                    deltalog = deltalog.filter((l) => l._stateID > id);\r\n                    this.log = [...this.log, ...deltalog];\r\n                    break;\r\n                }\r\n                case SYNC: {\r\n                    this.initialState = action.initialState;\r\n                    this.log = action.log || [];\r\n                    break;\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n        /**\r\n         * Middleware that intercepts actions and sends them to the master,\r\n         * which keeps the authoritative version of the state.\r\n         */\r\n        const TransportMiddleware = (store) => (next) => (action) => {\r\n            const baseState = store.getState();\r\n            const result = next(action);\r\n            if (!('clientOnly' in action) &&\r\n                action.type !== STRIP_TRANSIENTS) {\r\n                this.transport.sendAction(baseState, action);\r\n            }\r\n            return result;\r\n        };\r\n        /**\r\n         * Middleware that intercepts actions and invokes the subscription callback.\r\n         */\r\n        const SubscriptionMiddleware = () => (next) => (action) => {\r\n            const result = next(action);\r\n            this.notifySubscribers();\r\n            return result;\r\n        };\r\n        const middleware = applyMiddleware(TransientHandlingMiddleware, SubscriptionMiddleware, TransportMiddleware, LogMiddleware);\r\n        enhancer =\r\n            enhancer !== undefined ? compose(middleware, enhancer) : middleware;\r\n        this.store = createStore(this.reducer, this.initialState, enhancer);\r\n        if (!multiplayer)\r\n            multiplayer = DummyTransport;\r\n        this.transport = multiplayer({\r\n            transportDataCallback: (data) => this.receiveTransportData(data),\r\n            gameKey: game,\r\n            game: this.game,\r\n            matchID,\r\n            playerID,\r\n            credentials,\r\n            gameName: this.game.name,\r\n            numPlayers,\r\n        });\r\n        this.createDispatchers();\r\n        this.chatMessages = [];\r\n        this.sendChatMessage = (payload) => {\r\n            this.transport.sendChatMessage(this.matchID, {\r\n                id: nanoid(7),\r\n                sender: this.playerID,\r\n                payload: payload,\r\n            });\r\n        };\r\n    }\r\n    /** Handle incoming match data from a multiplayer transport. */\r\n    receiveMatchData(matchData) {\r\n        this.matchData = matchData;\r\n        this.notifySubscribers();\r\n    }\r\n    /** Handle an incoming chat message from a multiplayer transport. */\r\n    receiveChatMessage(message) {\r\n        this.chatMessages = [...this.chatMessages, message];\r\n        this.notifySubscribers();\r\n    }\r\n    /** Handle all incoming updates from a multiplayer transport. */\r\n    receiveTransportData(data) {\r\n        const [matchID] = data.args;\r\n        if (matchID !== this.matchID)\r\n            return;\r\n        switch (data.type) {\r\n            case 'sync': {\r\n                const [, syncInfo] = data.args;\r\n                const action = sync(syncInfo);\r\n                this.receiveMatchData(syncInfo.filteredMetadata);\r\n                this.store.dispatch(action);\r\n                break;\r\n            }\r\n            case 'update': {\r\n                const [, state, deltalog] = data.args;\r\n                const currentState = this.store.getState();\r\n                if (state._stateID >= currentState._stateID) {\r\n                    const action = update(state, deltalog);\r\n                    this.store.dispatch(action);\r\n                }\r\n                break;\r\n            }\r\n            case 'patch': {\r\n                const [, prevStateID, stateID, patch$1, deltalog] = data.args;\r\n                const currentStateID = this.store.getState()._stateID;\r\n                if (prevStateID !== currentStateID)\r\n                    break;\r\n                const action = patch(prevStateID, stateID, patch$1, deltalog);\r\n                this.store.dispatch(action);\r\n                // Emit sync if patch apply failed.\r\n                if (this.store.getState()._stateID === currentStateID) {\r\n                    this.transport.requestSync();\r\n                }\r\n                break;\r\n            }\r\n            case 'matchData': {\r\n                const [, matchData] = data.args;\r\n                this.receiveMatchData(matchData);\r\n                break;\r\n            }\r\n            case 'chat': {\r\n                const [, chatMessage] = data.args;\r\n                this.receiveChatMessage(chatMessage);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    notifySubscribers() {\r\n        Object.values(this.subscribers).forEach((fn) => fn(this.getState()));\r\n    }\r\n    overrideGameState(state) {\r\n        this.gameStateOverride = state;\r\n        this.notifySubscribers();\r\n    }\r\n    start() {\r\n        this.transport.connect();\r\n        this._running = true;\r\n        this.manager.register(this);\r\n    }\r\n    stop() {\r\n        this.transport.disconnect();\r\n        this._running = false;\r\n        this.manager.unregister(this);\r\n    }\r\n    subscribe(fn) {\r\n        const id = Object.keys(this.subscribers).length;\r\n        this.subscribers[id] = fn;\r\n        this.transport.subscribeToConnectionStatus(() => this.notifySubscribers());\r\n        if (this._running || !this.multiplayer) {\r\n            fn(this.getState());\r\n        }\r\n        // Return a handle that allows the caller to unsubscribe.\r\n        return () => {\r\n            delete this.subscribers[id];\r\n        };\r\n    }\r\n    getInitialState() {\r\n        return this.initialState;\r\n    }\r\n    getState() {\r\n        let state = this.store.getState();\r\n        if (this.gameStateOverride !== null) {\r\n            state = this.gameStateOverride;\r\n        }\r\n        // This is the state before a sync with the game master.\r\n        if (state === null) {\r\n            return state;\r\n        }\r\n        // isActive.\r\n        let isActive = true;\r\n        const isPlayerActive = this.game.flow.isPlayerActive(state.G, state.ctx, this.playerID);\r\n        if (this.multiplayer && !isPlayerActive) {\r\n            isActive = false;\r\n        }\r\n        if (!this.multiplayer &&\r\n            this.playerID !== null &&\r\n            this.playerID !== undefined &&\r\n            !isPlayerActive) {\r\n            isActive = false;\r\n        }\r\n        if (state.ctx.gameover !== undefined) {\r\n            isActive = false;\r\n        }\r\n        // Secrets are normally stripped on the server,\r\n        // but we also strip them here so that game developers\r\n        // can see their effects while prototyping.\r\n        // Do not strip again if this is a multiplayer game\r\n        // since the server has already stripped secret info. (issue #818)\r\n        if (!this.multiplayer) {\r\n            state = {\r\n                ...state,\r\n                G: this.game.playerView({\r\n                    G: state.G,\r\n                    ctx: state.ctx,\r\n                    playerID: this.playerID,\r\n                }),\r\n                plugins: PlayerView(state, this),\r\n            };\r\n        }\r\n        // Combine into return value.\r\n        return {\r\n            ...state,\r\n            log: this.log,\r\n            isActive,\r\n            isConnected: this.transport.isConnected,\r\n        };\r\n    }\r\n    createDispatchers() {\r\n        this.moves = createMoveDispatchers(this.game.moveNames, this.store, this.playerID, this.credentials, this.multiplayer);\r\n        this.events = createEventDispatchers(this.game.flow.enabledEventNames, this.store, this.playerID, this.credentials, this.multiplayer);\r\n        this.plugins = createPluginDispatchers(this.game.pluginNames, this.store, this.playerID, this.credentials, this.multiplayer);\r\n    }\r\n    updatePlayerID(playerID) {\r\n        this.playerID = playerID;\r\n        this.createDispatchers();\r\n        this.transport.updatePlayerID(playerID);\r\n        this.notifySubscribers();\r\n    }\r\n    updateMatchID(matchID) {\r\n        this.matchID = matchID;\r\n        this.createDispatchers();\r\n        this.transport.updateMatchID(matchID);\r\n        this.notifySubscribers();\r\n    }\r\n    updateCredentials(credentials) {\r\n        this.credentials = credentials;\r\n        this.createDispatchers();\r\n        this.transport.updateCredentials(credentials);\r\n        this.notifySubscribers();\r\n    }\r\n}\r\n/**\r\n * Client\r\n *\r\n * boardgame.io JS client.\r\n *\r\n * @param {...object} game - The return value of `Game`.\r\n * @param {...object} numPlayers - The number of players.\r\n * @param {...object} multiplayer - Set to a falsy value or a transportFactory, e.g., SocketIO()\r\n * @param {...object} matchID - The matchID that you want to connect to.\r\n * @param {...object} playerID - The playerID associated with this client.\r\n * @param {...string} credentials - The authentication credentials associated with this client.\r\n *\r\n * Returns:\r\n *   A JS object that provides an API to interact with the\r\n *   game by dispatching moves and events.\r\n */\r\nfunction Client(opts) {\r\n    return new _ClientImpl(opts);\r\n}\n\nexport { Client as C };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}